\chapter{Введение} % черновой вариант текста [изменения неизбежны]
% Что почитать
% http://habrahabr.ru/post/250745/
% http://habrahabr.ru/company/mosigra/blog/177249/
% http://inwebwetrust.org/trust/Game_Development_Dynamics_Playdeck.html
% https://developer.valvesoftware.com/wiki/Game_Mechanics_%28Portal_2%29:ru

% http://habrahabr.ru/post/255561/

В данном методическом руководстве я не буду давать информацию по установке и настройке компиляторов и 
сред разработки, так же как и советовать использовать конкретный язык программирования. Я попытаюсь 
изложить некоторые тонкости в разработке структуры игровых программ: частые ошибки, возможные проблемы и 
на что стоит обратить внимание при проектировании и разработке.

Примеры в основном будут на языке C++ с использованием следующих библиотек:
\begin{itemize}
    \item SDL2
    \item OpenGL
    \item GLUT
    \item OpenAL
    \item vorbis
\end{itemize}

Я глубоко надеюсь что прежде чем разрабатывать игру читатель определил для себя: \emph{идею}, \emph{жанр}, 
\emph{история}, \emph{стиль}, \emph{игровая механика} разрабатываемой игры. Но не стоит расстраиваться если 
у вас нет ещё идеи для игры -- давайте вместе шаг за шагом рассмотрим и напишем ремейк старой игры под 
названием Asteroids.

\chapter{Основа игровой программы}
\section{Введение}
С чего начинается проектирование игры? Обычно всё начинается с идеи. Наверное самый важный компонент 
любой игры. Конечно она может быть не столь яркой и интересной, но определив игровую механику можно 
сгладить этот изъян и получить довольно интересную и яркую игру. Немаловажным является то, что если у 
разрабатываемой игры появляется своя история и неповторимый стиль, которые только развивают идею и 
улучшают возникаемые впечатления от игры.

Но не будем филосовствовать на этот счёт и подойдём с другой стороны -- с технической. Для того чтобы начать
разрабатывать игру с нуля нам нужен некоторый \emph{скелет} (в другом случае -- использовать функции 
используемого фреймворка).

\section{Проектирование структуры игры}

Если говорить в общем, то самую простую структуру можно представить в следующем виде:
% картинка с 
% Инициализация -> Обработка событий -> Игровой цикл -> Рендеринг +-> Деинициализация
%                  ^-----------------------------------------------

\begin{figure}
    \label{img:skeleton}
\end{figure}

На этом простом \emph{скелет} мы и разработаем игровую программы. Конечно используемые \emph{скелеты} в 
профессиональной сфере могут (и будут) иметь более сложную структура, но для разработки простых игр, нам 
хватит и данной структуры.

Давайте рассмотрим каждый шаг в этой схеме. \textbf{Инициализация} -- блок подготовки и предобработки игровых
данных. Это может быть пред-/загрузка графических, звуковых и конфигурационных файлов. Список может быть 
и больше, в зависимости от конкретного типа игры: игровые карты, получение информации с игрового сервера, 
генерация параметров игровых предметов и многое другое. Говоря в общем -- это подготовка данных для игры.

Блок \textbf{обработки событий} в основном отвечает за работу с оконной системой, т.е. нажатая клавиша, 
передвинутый курсор, изменение размера окна программы и прочие события связанные с окном программы в 
операционной системе. 

Далее у нас по списку -- \textbf{игровой цикл}. Проводя аналогию с предыдущим блоком, то этот блок делает 
тоже самое, но для нашей игры -- двигает персонажей, обрабатывает игровые события и многие другие вещи, 
которые нам нужны в играх. Этот блок можно конечно разделить на много мелких, которые отвечают за 
отдельные части игровой программы, но мы остановимся на более общем виде. 

Ну и последнее в цикле это \textbf{рендеринг} -- основная часть структуры программы, без которой мы не могли 
бы представить пользователю графическую часть нашей игры. Всё что связано с обработкой и отрисовкой графики 
располагается здесь: от шейдеров до рисования точки на экране.

Внимательный читатель мог заметить и сказать: -- А где собственно работа со звуком? И он будет прав, в нашей 
структуре отсутствует звуковая система! Если быть честным, то звуковая система должна быть идти сразу после 
инициализации, но для того чтобы мы не слышали обрывки в воспроизведении звука она должна идти отдельным 
потоком. Таким образом звуковая система будет работать параллельно нашему циклу и не зависеть от его скорости 
выполнения. Также можно сказать, что стоит выносить в отдельный поток и рендеринг, так как при во многих 
случаях нужно обеспечивать приемлемую скорость его работы, а в данном потоке это не является возможным. 
Но так как наша игра не будет столь требовательной к скорости работы, то мы можем оставить всё как есть.

И наконец последний блок \textbf{деинициализация} -- освобождение выделенных в первом блоке ресурсов и 
устройств. Важный блок с точки зрения работы с памятью.

\section{Программная реализация скелета}
Давайте напишем \emph{скелет} программы шаг за шагом на примере работы с двумя разными библиотеками 
SDL2 и GLUT.

Для начала нам нужно выделить основные блоки, которые будут одинаковы в каждой программе независимо от 
используемой библиотеки, а также не забываем о предыдущем пункте, где мы рассматривали структуру типичной 
игровой программы.

\begin{lstlisting}
    void game_init( void ) { // initialization }
    void game_event( void ) { // event system }
    void game_loop( void ) { // game loop }
    void game_render( void ) { // render game frame }
    void game_destroy( void ) { // deinitialization }
    int main( int argc, char * argv[] ) {
        // entry point
        return EXIT_SUCCESS;
    }
\end{lstlisting}

Данный код больше подходить к использованию с библиотекой SDL2, в тоже время библиотека GLUT требует 
объявления \emph{callback}-функций, которые будут обрабатывать определенные события. Как пример приведу 
изменения, которые нужно совершить, чтобы удовлетворить программную архитектуру библиотеки GLUT.
\begin{lstlisting}
    void game_init( void ) { // initialization }
    void game_...( <params> ) { // callback function }
    void game_loop( int value ) { // game loop }
    void game_render( void ) { // render game frame }
    void game_destroy( void ) { // deinitialization }
    int main( int argc, char * argv[] ) {
        // entry point
        return EXIT_SUCCESS;
    }
\end{lstlisting}

Троеточием показано, что название функции будет зависеть от того, что мы хотим использовать: обработку 
событий от клавиатуры, мыши, окна и прочие. Давайте в текущем примере используем обработчик клавиатуры, но 
для этого определим параметры, которые нам будут нужны для работы с окном.

SDL2:
\begin{lstlisting}
    struct Window {
        const char * name = (const char *) "Skeleton";
        const int SDL_RENDER_DRIVER = 0;
        SDL_Window * window = nullptr;
        SDL_Renderer * render = nullptr;
        SDL_Event event;
        bool quit_flag = false;
        int width = 640;
        int height = 640;
    } gw;
\end{lstlisting}

GLUT:
\begin{lstlisting}
    struct Window {
        const char * name = (const char *) "Skeleton";
        GLint win_id = 0;
        GLint width = 640;
        GLint height = 640;
    } gw;
\end{lstlisting}

Основные параметры на которые стоит обратить внимание: \textbf{name} -- имя окна, \textbf{width} -- ширина, 
\textbf{height} -- высота. Это постоянные параметры, которые не будут меняться, а остальные зависят от используемой библиотеки. 
В случае с SDL2: \textbf{window} -- идентификатор окна, \textbf{render} -- контекст отрисовщика, \textbf{event} -- структура 
хранящая оконные события. Для GLUT пока только одно специфическое \textbf{win\_id} -- идентификатор окна.

Теперь можно перейти к определению функции обработки событий клавиатуры.

GLUT:
\begin{lstlisting}
    void game_keyboard( unsigned char key, int x, int y ) {
        static bool fullscreen = true;
        if ( key == 'q' ) {
            glutDestroyWindow( gw.win_id );
        } else if ( key == 'f' ) {
            if ( fullscreen ) {
                glutFullScreen();
            } else {
                glutReshapeWindow( gw.width, gw.height );
            }
            fullscreen = !fullscreen;
        }
    }
\end{lstlisting}

В данном отрывке кода представлено два события: закрытие окна по нажатию на клавишу 'q' и переключение между 
режимами экрана 'f'.

Основные функции:
\begin{itemize}
    \item glutDestroyWindow( GLint window\_handle ) -- уничтожение окна по идентификатору
    \item glutFullScreen( GLvoid ) -- переход в полноэкранный режим
    \item glutReshapeWindow( GLint width, GLint height ) -- изменение размера окна
\end{itemize}

Далее рассмотрим использование каждой библиотеки по отдельности.

\subsection{SDL2}
Давайте постепенно функция за функцией опишем \textbf{скелет} программы. Первое с чего начнём -- функция 
обработки ошибок. В дальнейшем она нам будет очень полезна, да и пользователь сможет понять что случилось при 
экстренном закрытии программы.

\begin{lstlisting}
    void game_send_error( int code ) {
        SDL_ShowSimpleMessageBox( SDL_MESSAGEBOX_ERROR, "Error", SDL_GetError(), nullptr );
        exit( code );
    }
\end{lstlisting}

Библиотечная функция \emph{SDL\_ShowSimpleMessageBox} принимает несколько параметров на вход, а именно:
\begin{enumerate}
    \item тип икона
    \item заголовок окна
    \item выводимое сообщение
    \item тип используемых кнопок (если ноль или \textbf{nullptr}, то кнопка OK)
\end{enumerate}

Код прозрачен и прост -- в случае ошибки мы выводим её на экран, а далее закрываем программы с 
соответствующим кодом. 

Идём далее и реализуем код для точки входа в программу используя рис.~\ref{img:skeleton}.
\begin{lstlisting}
    int main( int argc, char * argv[] ) {
        game_init();
        while ( !gw.quit_flag ) {
            game_event();
            game_loop();
            game_render();
        }
        game_destroy();
        return EXIT_SUCCESS;
    }
\end{lstlisting}

Главное на что стоит обратить внимание, так это параметр \textbf{quit\_flag}, который будет сигнализировать 
нам о закрытии программы. В остальном всё соответствует рис.~\ref{img:skeleton}).

Теперь пойдём последовательно по блокам и опишем каждый из них. Начнём с рассмотрения псевдокода, а потом 
напишем сам код.

Всё что нужно, чтобы инициализировать систему на данном этапе, так это несколько шагов:
\begin{enumerate}
    \item инициализировать SDL2
    \item создать окно
    \item создать контекст отрисовщика
    \item обработать предыдущие шаги на ошибки
\end{enumerate}

Так давайте сделаем это:

\begin{lstlisting}
    void game_init( void ) {
        SDL_Init( SDL_INIT_VIDEO | SDL_INIT_EVENTS );
        gw.window = SDL_CreateWindow( gw.name, SDL_WINDOWPOS_CENTERED, 
            SDL_WINDOWPOS_CENTERED, gw.width, gw.height, 
            SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE );
        if ( gw.window == nullptr ) {
            game_send_error( EXIT_FAILURE );
        }
        gw.render = SDL_CreateRenderer( gw.window, gw.SDL_RENDER_DRIVER, 
            SDL_RENDERER_SOFTWARE | SDL_RENDERER_PRESENTVSYNC );
        if ( gw.render == nullptr ) {
            game_send_error( EXIT_FAILURE );
        }
    }
\end{lstlisting}

Рассмотрим кратко каждую из них (так как подробно описано в вики проекта \cite{sdl2wiki}).

\begin{itemize}
    \item SDL\_Init -- инициализация систем SDL2 (видео, аудио, клавиатура \ldots)
    \item SDL\_CreateWindow -- создание окна приложения
    \item SDL\_CreateRender -- функция инициализации контекста отрисовщика
\end{itemize}

Блоки где производятся сравнения с нулевым указателем -- это блоки обработки ошибок.

... продолжение следует ...

\subsection{GLUT}
....

\section{Игровая механика}
\subsection{Физика}
Что использовать: простой самописный движок или готовое решение?
\subsection{Рейтинг, бонусы и прочее}
\section{Логика игры}
\section{...}

\chapter{Работа с графикой} % описание работы с графикой
\section{Загрузка}
\section{Отрисовка}
\section{Анимация}
\section{Создание шрифтов}
\section{Эффекты (создание и использование)}
\section{...}

\chapter{Работа со звуком} % описание работы с библиотеками OpenAL, vorbis
\section{Инициализация}
\section{Воспроизведение}
\section{...}

\chapter{Работа с игровыми ресурсами}
\section{Модуль загрузки / выгрузки}
\section{...}

\chapter{Игровые события}
\section{Связь игровых событий с графикой и звуком}
\section{Обратная связь (с игроком)}
\section{...}

\chapter{Справка}
\section{Полезные ресурсы разработчику}
Если у вас в команде нет художников или музыкантов, или вам нужно узнать определенные подробности по работе 
с тем или иным инструментом, то во многих случаях можно воспользоваться помощью интернета. Заказать у 
художника арты, у композитора фоновую музыку или обсудить тонкий вопрос по использования специфичного 
алгоритма, то в данном случае лучшим решением будет обратиться к следующим интернет источникам.

\begin{itemize}\itemsep-5pt
    \item FAQ по геймдизайну \url{http://www.sloperama.com/advice.html}
    \item Авторский блог Антона Карпова по разработке игр \url{http://www.ant-karlov.ru/}
    \item Аналог stackoverflow по gamedev \url{http://gamedev.stackexchange.com/}
    \item Блог посвященный созданию 2D графики \url{http://2dgameartforprogrammers.blogspot.ru/}
    \item Блог Райана Швайдера по gamedesign \url{http://www.nerfbat.com/lessons/}
    \item Источник свободных игровых ресурсов (CC0) \url{http://opengameart.org/}
    \item Крупнейшее сообщество модостроителей \url{http://moddb.com/}
    \item Крупные сообщества по игрострою \url{http://www.gamedev.ru/} (rus) и \url{http://www.gamedev.net/} (eng)
    \item Любительские конкурсы по разработке игр \url{http://igdc.ru/}
    \item Новости индустрии, блоги разработчиков и многое другое \url{http://gamasutra.com/}
    \item Сайт для специалистов по компьютерной графике \url{http://devmaster.net/}
    \item Сайт посвященный pixelart \url{http://www.pixeljoint.com/}
    \item Уроки по созданию 3D \\
        \url{http://www.digitaltutors.com/subject/game-development-asset-creation-tutorials}
    \item Игровые спрайты старый игр \url{http://www.videogamesprites.net/}
    \item Свободный игровой контент \url{http://freegamearts.tuxfamily.org/}
    \item База свободных звуков \url{http://www.freesound.org/}
    \item Открытый музыкальный архив \url{http://www.openmusicarchive.org/}
    \item Базы 3D моделей \url{http://www.katorlegaz.com/3d_models/index.php}\\
        \url{https://3dwarehouse.sketchup.com/?redirect=1}
    \item CG текстуры \url{http://www.cgtextures.com/}
    \item Свободные архивы по текстурам \url{http://www.mayang.com/textures/}\\
        \url{http://www.texturearchive.com/}
    \item Библиотеки шрифтов \url{http://openfontlibrary.org/}\\
        \url{https://www.acidfonts.com/}
    \item Хабрахабр \url{http://habrahabr.ru}
\end{itemize}

Список книг по gamedev:
\begin{itemize}
    \item Invent Your Own Computer Games with Python \url{https://inventwithpython.com/chapters/}
    \item Making Games with Python & Pygame \url{https://inventwithpython.com/pygame/chapters/}
    \item Sylvester,~T. Designing Games: A Guide to Engineering Experiences. O'Reilly Media, 2013
    \item Nystrom,~R. Game Programming Patterns \url{http://gameprogrammingpatterns.com/}
    \item ...
\end{itemize}

\renewcommand{\bibname}{Список используемой литературы}
\addcontentsline{toc}{chapter}{Список используемой литературы}
\begin{thebibliography}{10}
    \bibitem{main} Sylvester,~T. Designing Games: A Guide to Engineering Experiences. O'Reilly Media, 2013 
    \bibitem{pat} Nystrom,~R. Game Programming Patterns. --- Available at: 
        \url{http://gameprogrammingpatterns.com/}
    \bibitem{sdl2wiki} SDL2 wiki \url{https://wiki.libsdl.org/FrontPage}
\end{thebibliography}