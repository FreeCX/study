\chapter{Проектирование игровой программы}
\section{Введение}

В данном методическом руководстве я не буду давать информацию по установке и настройке компиляторов и 
сред разработки, так же как и советовать использовать конкретный язык программирования. Я попытаюсь 
изложить некоторые тонкости в разработке структуры игровых программ: частые ошибки, возможные проблемы и 
на что стоит обратить внимание при проектировании и разработке.

Примеры в основном будут на языке C++ с использованием следующих библиотек:
\begin{itemize}
    \item SDL2
    \item OpenGL
    \item GLUT
    \item OpenAL
    \item vorbis
\end{itemize}

Я глубоко надеюсь что прежде чем разрабатывать игру читатель определил для себя: \emph{идею}, \emph{жанр}, 
\emph{история}, \emph{стиль}, \emph{игровая механика} разрабатываемой игры. Но не стоит расстраиваться если 
у вас нет ещё идеи для игры -- давайте вместе шаг за шагом рассмотрим и напишем ремейк старой игры под 
названием Asteroids.

С чего начинается проектирование игры? Обычно всё начинается с идеи. Наверное самый важный компонент 
любой игры. Конечно она может быть не столь яркой и интересной, но определив игровую механику можно 
сгладить этот изъян и получить довольно интересную и яркую игру. Немаловажным является то, что если у 
разрабатываемой игры появляется своя история и неповторимый стиль, которые только развивают идею и 
улучшают возникаемые впечатления от игры.

Но не будем филосовствовать на этот счёт и подойдём с другой стороны -- с технической. Для того чтобы начать
разрабатывать игру с нуля нам нужен некоторый \emph{скелет} (в другом случае -- использовать функции 
используемого фреймворка).

\pagebreak

\section{Проектирование структуры игры}
Если говорить в общем, то самую простую структуру можно представить следующей блок-схемой 
(рис.~\ref{img:skeleton}). На этом простом \emph{скелет} мы и разработаем игровую программы. Конечно 
используемые \emph{скелеты} в профессиональной сфере могут (и будут) иметь более сложную структура, но 
для разработки простых игр, нам хватит и данной структуры.

Давайте рассмотрим каждый шаг в этой схеме. \textbf{Инициализация} -- блок подготовки и предобработки 
игровых данных. Это может быть пред-/загрузка графических, звуковых и конфигурационных файлов. Список может 
быть и больше, в зависимости от конкретного типа игры: игровые карты, получение информации с игрового 
сервера, генерация параметров игровых предметов и многое другое. Говоря в общем -- это подготовка данных 
для игры.

\begin{wrapfigure}[18]{r}{0.22\linewidth}
    \includegraphics[width=0.2\textwidth]{game_loop}
    \caption{Структура игрового цикла}
    \label{img:skeleton}
\end{wrapfigure}

Блок \textbf{обработки событий} в основном отвечает за работу с оконной системой, т.е. нажатая клавиша, 
передвинутый курсор, изменение размера окна программы и прочие события связанные с окном программы в 
операционной системе. 

Далее у нас по списку -- \textbf{игровой цикл}. Проводя аналогию с предыдущим блоком, то этот блок делает 
тоже самое, но для нашей игры -- двигает персонажей, обрабатывает игровые события и многие другие вещи, 
которые нам нужны в играх. Этот блок можно конечно разделить на много мелких, которые отвечают за 
отдельные части игровой программы, но мы остановимся на более общем виде. 

Ну и последнее в цикле это \textbf{рендеринг} -- основная часть структуры программы, без которой мы не могли 
бы представить пользователю графическую часть нашей игры. Всё что связано с обработкой и отрисовкой графики 
располагается здесь: от шейдеров до рисования точки на экране.

Внимательный читатель мог заметить и сказать: -- А где собственно работа со звуком? И он будет прав, в нашей 
структуре отсутствует звуковая система! Если быть честным, то звуковая система должна быть идти сразу после 
инициализации, но для того чтобы мы не слышали обрывки в воспроизведении звука она должна идти отдельным 
потоком. Таким образом звуковая система будет работать параллельно нашему циклу и не зависеть от его скорости 
выполнения. Также можно сказать, что стоит выносить в отдельный поток и рендеринг, так как при во многих 
случаях нужно обеспечивать приемлемую скорость его работы, а в данном потоке это не является возможным. 
Но так как наша игра не будет столь требовательной к скорости работы, то мы можем оставить всё как есть.

И наконец последний блок \textbf{деинициализация} -- освобождение выделенных в первом блоке ресурсов и 
устройств. Важный блок с точки зрения работы с памятью.

\pagebreak

\section{Программная реализация скелета}
Давайте напишем \emph{скелет} программы шаг за шагом на примере работы с двумя разными библиотеками 
SDL2 и GLUT.

Для начала нам нужно выделить основные блоки, которые будут одинаковы в каждой программе независимо от 
используемой библиотеки, а также не забываем о предыдущем пункте, где мы рассматривали структуру типичной 
игровой программы.

\begin{lstlisting}
    void game_init( void ) { // инициализация }
    void game_event( void ) { // обработка событий }
    void game_loop( void ) { // игровой цикл }
    void game_render( void ) { // функция рендеринга }
    void game_destroy( void ) { // деинициализация }
    int main( int argc, char * argv[] ) {
        // точка входа в программу
        return EXIT_SUCCESS;
    }
\end{lstlisting}

Данный код больше подходить к использованию с библиотекой SDL2, в тоже время библиотека GLUT требует 
объявления \emph{callback}-функций, которые будут обрабатывать определенные события. Как пример приведу 
изменения, которые нужно совершить, чтобы удовлетворить программную архитектуру библиотеки GLUT.

\begin{lstlisting}
    void game_init( void ) { // инициализация }
    void game_...( <params> ) { // callback функции }
    void game_loop( int value ) { // игровой цикл }
    void game_render( void ) { // функция рендеринга }
    void game_destroy( void ) { // деинициализация }
    int main( int argc, char * argv[] ) {
        // точка входа в программу
        return EXIT_SUCCESS;
    }
\end{lstlisting}

Троеточием показано, что название функции будет зависеть от того, что мы хотим использовать: обработку 
событий от клавиатуры, мыши, окна и прочие. Давайте в текущем примере используем обработчик клавиатуры, но 
для этого определим параметры, которые нам будут нужны для работы с окном.

SDL2:
\lstinputlisting[firstline=3, lastline=13]{../game/01_init/src/sdl2_init.cpp}

\pagebreak

GLUT:
\lstinputlisting[firstline=3, lastline=10]{../game/01_init/src/glut_init.cpp}

Основные параметры на которые стоит обратить внимание: \textbf{name} -- имя окна, \textbf{width} -- ширина, 
\textbf{height} -- высота. Это постоянные параметры, которые не будут меняться, а остальные зависят от 
используемой библиотеки. В случае с SDL2: \textbf{window} -- идентификатор окна, \textbf{render} -- контекст 
отрисовщика, \textbf{event} -- структура хранящая оконные события. Для GLUT пока только одно специфическое 
\textbf{win\_id} -- идентификатор окна.

Теперь можно перейти к определению функции обработки событий клавиатуры.

GLUT:
\lstinputlisting[firstline=25, lastline=38]{../game/01_init/src/glut_init.cpp}

В данном отрывке кода представлено два события: закрытие окна по нажатию на клавишу 'q' и переключение между 
режимами экрана 'f'.

Основные функции:
\begin{itemize}
    \item glutDestroyWindow( GLint window\_handle ) -- уничтожение окна по идентификатору
    \item glutFullScreen( GLvoid ) -- переход в полноэкранный режим
    \item glutReshapeWindow( GLint width, GLint height ) -- изменение размера окна
\end{itemize}

Далее рассмотрим использование каждой библиотеки по отдельности.

\pagebreak

\subsection{SDL2}
Давайте постепенно функция за функцией опишем \textbf{скелет} программы. Первое с чего начнём -- функция 
обработки ошибок. В дальнейшем она нам будет очень полезна, да и пользователь сможет понять что случилось при 
экстренном закрытии программы.

\lstinputlisting[firstline=15, lastline=20]{../game/01_init/src/sdl2_init.cpp}

Библиотечная функция \emph{SDL\_ShowSimpleMessageBox} принимает несколько параметров на вход, а именно:
\begin{enumerate}
    \item тип икона
    \item заголовок окна
    \item выводимое сообщение
    \item тип используемых кнопок (если ноль или \textbf{nullptr}, то кнопка OK)
\end{enumerate}

Код прозрачен и прост -- в случае ошибки мы выводим её на экран, а далее закрываем программы с 
соответствующим кодом. 

Идём далее и реализуем код для точки входа в программу используя рис.~\ref{img:skeleton}.
\lstinputlisting[firstline=87, lastline=97]{../game/01_init/src/sdl2_init.cpp}

Главное на что стоит обратить внимание, так это параметр \textbf{quit\_flag}, который будет сигнализировать 
нам о закрытии программы. В остальном всё соответствует рис.~\ref{img:skeleton}.

Теперь пойдём последовательно по блокам и опишем каждый из них. Начнём с рассмотрения псевдокода, а потом 
рассмотрим на примере работающего кода.

Всё что нужно, чтобы инициализировать систему на данном этапе, так это несколько шагов:
\begin{enumerate}
    \item инициализировать SDL2
    \item создать окно
    \item создать контекст отрисовщика
    \item обработать предыдущие шаги на ошибки
\end{enumerate}

Так давайте сделаем это:

\lstinputlisting[firstline=68, lastline=85]{../game/01_init/src/sdl2_init.cpp}

Рассмотрим кратко каждую из них (так как подробно описано в вики проекта \cite{sdl2wiki}).

\begin{itemize}
    \item SDL\_Init -- инициализация систем SDL2 (видео, аудио, клавиатура \ldots)
    \item SDL\_CreateWindow -- создание окна приложения
    \item SDL\_CreateRender -- функция инициализации контекста отрисовщика
\end{itemize}

Блоки, где производятся сравнения с нулевым указателем -- это обработка ошибок.

Далее следует блок обработки событий. На этапе проектирования он будет иметь минимальный функционал:
\begin{itemize}
    \item обработка закрытия программы
    \item обработка изменения размера окна
    \item шаблон для обработки нажатия клавиш
\end{itemize}

В программном коде это будет выглядеть так:
\lstinputlisting[firstline=22, lastline=47]{../game/01_init/src/sdl2_init.cpp}

При вызове данной функции происходит следующее: с помощью \emph{SDL\_PollEvent} мы запрашиваем текущее 
событие от системы SDL2, а далее с помощью конструкции \textbf{switch-case} выбираем соответствующую 
ветку для обработки. Всего их сейчас три, не считая \textbf{default}. 

Первая \emph{SQL\_QUIT} -- отвечает за обработку события выхода из программы -- в нашем случае это 
установка булевой функции в значение \textbf{true}, что обеспечит нам выход из основного цикла.

Вторая \emph{SDL\_WINDOWEVENT} и \emph{SDL\_WINDOWEVENT\_RESIZED} отвечают за изменение размеров 
окна и соответствующее внесение изменения в параметры нашей структуры (\emph{gw.width} и 
\emph{gw.height}).

И последнее событие \emph{SDL\_KEYDOWN} отвечающее за нажатие клавиш. В данном случае нам нужно 
ещё узнать какая именно клавиша была нажата (\emph{gw.event.key.keysym.sym}) и соответственно 
как-то отреагировать на это. В нашем случае это обработка клавиши \emph{Esc} и установка флага 
выхода в значение \textbf{true} (ещё один способ закрытия окна по событию).

На текущий момент момент это всё, что нужно для работы обработчика событий в нашей программе, но нам 
также нужно будет обрабатывать события отжатия клавиш \emph{SDL\_KEYUP}, но его мы разберём подробно 
при разработке игры.

Следующий три немаловажный блока -- игровой цикл, рендеринг и деинициализация. Мы рассмотрим их 
вместе, так как они сейчас имеют наименьший объём кода и являются просто заглушками в программе.
\lstinputlisting[firstline=49, lastline=66]{../game/01_init/src/sdl2_init.cpp}

Выглядит довольно просто не так ли? Остановимся на отрисовщике и функции деинициализации подробнее.

Чтобы наша программа могла рисовать в поле \emph{renderer} нужно его подготовить функцией 
\emph{SDL\_RenderClear}, которая очищает предыдущий кадр и заливает поле отрисовки в установленный 
цвет (по стандарту чёрный). Далее мы можем производить любые действия с ним. В конце отрисовки мы 
должны перенести все произведенные манипуляции на экран, чем и занимается функция 
\emph{SDL\_RenderPresent}.

Для деинициализации окна нам нужно проделать несколько простых действий:
\begin{itemize}
    \item освободить контекст рендера: \emph{SDL\_DestroyRenderer}
    \item закрыть окно созданное SDL2: \emph{SDL\_DestroyWindow}
    \item выйти из программы: \emph{SDL\_Quit}
\end{itemize}

На этом наша заготовка готова к работе. Полный код можно посмотреть в разделе \ref{code:skeletonSDL2}

\subsection{GLUT}
С библиотекой GLUT дела обстоят похожим образом. Отличия состоят в способе организации обработки событий.
В основном GLUT использует \textbf{callback} функции для организации псевдо-ООП подход. Удобный подход, но 
требующий организации более своеобразной структуры работы, но имеющий главный плюс -- работа в отдельных 
потоках (рендеринг, обработка событий и т.д.), что хорошо влияет на общую производительность программы 
(в отличии от последовательной обработки всех событий). Рассмотрим также основные блоки формирующие 
программу.

Начнём с точки входа в программу:
\lstinputlisting[firstline=59, lastline=66]{../game/01_init/src/glut_init.cpp}

Здесь всё довольно просто, за исключением отсутствия игрового цикла (как в программе с SDL2). Ну давайте 
пойдём по порядку.
\begin{itemize}
    \item glutInit -- функция инициализации GLUT среды
    \item game\_init -- наша функция инициализации
    \item glutMainLoop -- функция отвечающая за обработку событий GLUT (эта функции никогда не 
        возвращается, наша программа по существу входит в бесконечный цикл)
    \item game\_destroy -- наша функция деинициализации
\end{itemize}

Теперь перейдём к инициализации. Используя GLUT на нужно произвести некоторые действия, для того чтобы 
создать окно с контекстом для рисования, плюс нужно указать какие мы будем использовать callback-функции 
в нашей программе. Выделим необходимые действия, которые нужно совершить
\begin{itemize}
    \item создать окно
    \item определить функцию рендеринга
    \item определить функцию обработки событий клавиатуры
    \item произвести настройку OpenGL контекста
\end{itemize} 

Теперь реализуем данные действия в коде:
\lstinputlisting[firstline=40, lastline=52]{../game/01_init/src/glut_init.cpp}

Строки с 3 по 8 отвечают за создание окна, а именно:
\begin{itemize}
    \item[3-4] получение размера экрана
    \item[5-6] установка размера окна и его положения
    \item[7] установка параметров контекста для отрисовки 
        (RGBA палитра и использование двойной буферизации)
    \item[8] создание окна
\end{itemize}

Далее идут функции:
\begin{itemize} 
    \item glutDisplayFunc которая получает callback-функцию нашего рендера
    \item glutKeyboardFunc которая получает callback-функцию нашего обработчика клавиатуры
    \item glutTimerFunc -- функция таймера, которая будет вызывать game\_loop с заданным интервалом
\end{itemize}

И под конец OpenGL функция \emph{glClearColor}, которая устанавливает цвет очистки экрана.

Функцию обработки клавиатуры имеет очень простую структуру в основе. При её вызове, ей передаётся 
значение нажатой кнопки. В зависимости от её кода, мы выбираем то или иное действие (мы рассмотрели 
работу кода ранее).

Последние несколько функции рассмотрим вместе. Функция освобождения ресурсов в нашем случае будет только 
заглушкой, поэтому текущий код будет выглядеть так:

\lstinputlisting[firstline=54, lastline=57]{../game/01_init/src/glut_init.cpp}

И ещё остаётся две функции, которые будут получаются связанными

\lstinputlisting[firstline=12, lastline=23]{../game/01_init/src/glut_init.cpp}

В функции отрисовки всё довольно тривиально: с помощью функции \emph{glClear} очищаем предыдущее 
состояние окна, выполняем свои действия и под конец вызываем функцию \emph{glutSwapBuffers}, которая 
меняет буферы отрисовки местами и выводит картинку на экран.

Функция отвечающая за игровой цикл отвечает как за вызов функции отрисовки, так и за обработку игровых 
событий. Но главный минус заключается в том что нам нужно каждый раз вызывать функцию таймер, который 
будет вызывать функцию игрового цикла.

\subsection{Заключение}
Мы рассмотрели две различных технологии: GLUT (с контекстом отрисовки OpenGL) и SDL2 (со стандартным 
контекстом отрисовки). Далее будем использовать SDL2, так как:
\begin{itemize}
    \item имеет более свежую базу кода
    \item он более прост в работе
    \item большой функционал с поддержкой <<из коробки>>
    \item есть возможность выбора драйвера отрисовщика (OpenGL, software и другие)
\end{itemize} 

\pagebreak

\section{Игровая механика}

Давайте теперь перейдём непосредственно к разработке игры <<Asteroids>>. Поиграть в игру можно на сайте 
\url{http://www.freeasteroids.org}, где собственно можно понять основные моменты игровой механики данной 
игры.

Давайте определимся с объектами, которые задействованы в игре:
\begin{itemize}
    \item корабль игрока
    \item астероиды
    \item снаряды игрока
\end{itemize}

Это основные объекты, которые присутствуют в данной игре. Давайте более подробно рассмотрим каждый объект 
более пристально и опишем их.

\subsection{Игрок}
Корабль игрока -- главный персонаж данной игры. Он обладает несколькими основными действиями:
\begin{itemize}
    \item выстрелить снаряд по направлению
    \item повернуть корабль относительно его центра
    \item передвинуть корабль по направлению
\end{itemize}

Отсюда мы можем выделить основные параметры, которые нам будут нужны для его проектирования: координаты 
центра, угол поворота, скорость и количество жизней. Ещё стоит заметить, что игровой экран имеет зацикленную 
структуру: то есть если мы летим в право, то при пересечении границы игрового поля мы вылетим с левой 
стороны и соответственно и с верхом и низом. Но при определении базовой структуры класса игрока данный 
функционал нам не требуется, поэтому при реализации движения игрока рассмотрим данную возможность 
подробнее. Давайте теперь реализуем нашу структуру в коде\footnote{Вы можете заметить незнакомый 
    (ну или неопределенный) класс \emph{vec2} -- это двумерная система координат, которая будет 
    использоваться в данном проекте. Код и заголовочный файл приложены в разделе \ref{code:vec2}.}.
\begin{lstlisting}
    class Player {
    public:
        Player() : p( vec2( 0.0f, 0.0f ) ), life( 3 ), 
                   velocity( 0.0f ), angle( 0.0f ) {}
    private:
        vec2 p; // векторное представление координат корабля
        short life; // количество жизней
        float velocity, angle; // скорость и угол поворота
    };
\end{lstlisting}

Это только базовый шаблон для игрового корабля. Нам также нужно будет сюда добавить несколько дополнительных 
функций, которые будут отвечать за отрисовку, передвижение, столкновение и прочие вспомогательные функции 
в игре, но рассмотрение и реализацию отложим на последующие главы.

\subsection{Астероиды}
Астероиды в игре можно представить в виде группы объектов, которые будут управляться базовым классом.
У них не так много возможностей: движение в заданном направлении. Чтобы наша игра была более живой и 
интересной мы добавим астероидам: угловую скорость и возможность сталкиваться друг с другом. 
Каждый астероид можно охарактеризовать некоторым набором параметров: позиция, скорость, радиус, угловая 
скорость и угол. Давайте же опишем базовый класс.
\begin{lstlisting}
    #include <vector>

    typedef struct {
        vec2 p, v; // позиция и скорость
        int radius; // радиус
        float angle, rotate; // угол и угловая скорость
    } asteroid_t;

    typedef std::vector< asteroid_t > asteroid_v; 

    class AsteroidSystem {
    public:
        AsteroidSystem( const int width, const int height, 
                        const int asteroid_count, const int segment_count );
        ~AsteroidSystem();
    private:
        void collide( int i, int j );
        asteroid_v asteroids;
        int asteroid_count;
        int segment_count;
        float * segments;
        int * pos;
        float * dist;
    };
\end{lstlisting}

В данном коде мы определили структуру описывающую один астероид и класс, который будет управлять всеми 
созданными астероидами. Пока описан только конструктор в который передаётся значения размера игровой 
комнаты, количество астероидом и количество сегментов на них (да их детализации) и пустой деструктор.
Также среди параметров будем хранить количество астероидом и количество их сегментов, а также несколько 
массивов:
\begin{itemize}
    \item segments -- массив для хранения координат круга
    \item pos -- вспомогательная структура для хранения промежуточных данных
    \item dist -- массив для хранения неровностей астероида
\end{itemize} 
Более подробно остановимся на этих параметрах, когда будем рассматривать раздел работы с графикой.

И последнее -- функция \emph{collide} которая будет обрабатывать столкновения между астероидами.

\subsection{Снаряды}
Для описания снарядов нам понадобиться всего несколько параметров: позиция, время жизни, угол и скорость.
Как и в прошлом пункте, нам нужна система, которая будет управлять всеми снарядами. Поэтому мы выделим 
эти пункты в структуру, а класс уже будет иметь доступ ко всему массиву. Опишем данную структуру в коде.

\begin{lstlisting}
    #include <vector>

    typedef struct {
        vec2 p; // позиция
        short life; // время жизни
        float angle, velocity; // угол и скорость
    } bullet_t;

    typedef std::vector< bullet_t > bullet_v;

    class BulletSystem {
    public:
        BulletSystem( const float velocity, const short life, const short radius );
        ~BulletSystem();
    private:
        bullet_v bullets;
        // стандартные значения для
        float max_velocity; // скорости
        short max_life; // времени жизни
        short max_radius; // радиуса
    };
\end{lstlisting}

Как видно из класса управляющего снарядами мы имеем конструктор принимающий значения скорости, 
времени жизни и радиуса снаряда, которые будут создаваться во время игры и пока пустой деструктор. Также 
мы здесь указали параметры в которых мы будем хранить данные принятые конструктором, ну и массив для 
хранения самих снарядов.

\subsection{Заключение}
На данном этапе мы сделали минимальное описание структуры наших игровых объектов. Пока мы не объявили 
функции отвечающие за рисование самих объектов, обработку столкновений и остального функционала, но уже 
заложили основу для проектирования игры. В следующих разделах мы рассмотрим работу с графикой и звуком, а 
также напишем их реализацию, которая нам понадобиться в игре.

\pagebreak

\chapter{Работа с графикой}
В данной главе мы рассмотрим и реализуем модуль минимальным функционалом для работы с графикой. 
Всё что нужно нам для создания игры это:
\begin{itemize}\itemsep-5pt
    \item цвет
    \item линия
    \item круг
    \item шрифт
\end{itemize}

Но прежде чем мы начнём с реализации давайте определим класс (назовём его DrawSystem), который будет отвечать 
за работу с графикой. DrawSystem должен включать в себя следующие функции:
\begin{itemize}\itemsep-5pt
    \item конструктор
    \item деструктор
    \item функции для работы с цветом
    \item функция рисования круга
    \item функция рисования линии
\end{itemize}

Следующий код определяет наши требования:
\lstinputlisting[firstline=16, lastline=31]{../game/02_minimal/src/draw.hpp}

Отметим несколько особенностей данного кода: нам требуются такие переменные как область для рисования (render),
массив для хранения единичной окружности (coords) и количество сегментов в данной окружности (segments). 
Если с \emph{render} более менее может быть понятно, то для чего нужны \emph{coords} и \emph{segments}? Давайте 
рассмотрим как рисуется окружность.

\section{Окружность}
Давайте сразу приступим к математической части. Окружность можно описать следующим уравнение в декартовой 
системе координат:
\[
    x^2 + y^2 = r^2
\]
где \( x \) и \( y \) -- декартовы координаты, а \( r \) -- радиус окружности.

Но так уж сложилось, что нам для рисования нужно знать координаты, поэтому данная формула нам не очень 
подходит. Стоит посмотреть в сторону параметрических уравнений:
\[
    \left\{ \begin{array}{l}
        x = x_0 + r \cdot \cos\phi \\
        y = y_0 + r \cdot \sin\phi 
    \end{array} \right., 0 \leq \phi < 2\pi
\]

Данная формула уже намного удобнее, так как нам нужно изменять всего лишь один параметр \( \phi \), для 
того чтобы нарисовать окружность. Заметим сразу следующее, что мы будем рисовать окружность как набор 
линий (или сегментов), т.е. нам нужно сразу определять четыре координаты. 

Реализацию данного метода можно проиллюстрировать следующим кодом:

\begin{lstlisting}
    int DrawSystem::circle( int x, int y, int r ) {
        float dphi = 2.0f * M_PI / 20; // размер сегмента окружности
        float xp1, yp1, xp2, yp2;
        int result = 0; // результат выполнения кода

        for ( float phi = 0; phi < 2.0f * M_PI; phi += dphi ) {
            xp1 = x + r * cos( phi ); 
            yp1 = y + r * sin( phi );
            xp2 = x + r * cos( phi + dphi );
            yp2 = y + r * sin( phi + dphi );
            result |= SDL_RenderDrawLine( render, xp1, yp1, xp2, yp2 );
        } 
        return result;
    }
\end{lstlisting}

\pagebreak

В результате мы получим, что-то в этом виде:
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.47\textwidth]{circle_01}
    \caption{Пример рисования нескольких окружностей разного радиуса}
    \label{img:circleExample}
\end{figure}

Получилось довольно не плохо, если не учитывать что мы при рисование каждой окружности должны считать 
значения \( \sin \) и \( \cos \) каждый раз, что не есть хорошо. Ещё одним минусом является, что 
окружность рисуется с зазубринами -- это конечно не плохо, но можно сделать и сглаженный вариант, но 
давайте сначала разберёмся с начальным предрасчётом, а в следующем разделе поговорим про рисовании 
гладких линий.

Для того чтобы нам каждый раз не считать значения \( \sin \) и \( \cos \) мы можем на этапе 
инициализации нашего класса DrawSystem один раз их подсчитать для окружности единичного радиуса, а 
далее в коде всего лишь домножать на радиус. Предоставлю сразу код для конструктора и деструктора, 
который реализует данную функциональность\footnote{Данный код хранит значения \( x \) и 
\( y \) координаты в одном массиве. Обычно такой способ хранения данных используют для передачи 
данных OpenGL и многие другие библиотеки работающие с графикой.}:
\lstinputlisting[firstline=3, lastline=17]{../game/02_minimal/src/draw.cpp}

\pagebreak

И соответственно изменяем код рисующий окружность\footnote{Внимательный читатель может заметить, 
что теперь \( xp1, xp2, yp1, yp2 \) имеют тип \emph{int} и в коде используется функция 
\emph{round} -- это нужно для более точного рисования окружности без грубого перевода \emph{float} в 
\emph{int} путём отсечения дробной части}:
\begin{lstlisting}
    int DrawSystem::circle( int x, int y, int r ) {
        int xp1, xp2, yp1, yp2;
        int result = 0;

        // проходим по всем сегментам
        for ( size_t i = 0; i < segments * 2; i += 2 ) {
            xp1 = x + round( r * coords[i+0] );
            yp2 = y + round( r * coords[i+1] );
            if ( i == ( segments - 1 ) * 2 ) {
                xp2 = x + round( r * coords[0]   );
                yp2 = y + round( r * coords[1]   );
            } else {
                xp2 = x + round( r * coords[i+2] );
                yp2 = y + round( r * coords[i+3] );
            }
            result |= SDL_RenderDrawLine( render, xp1, yp1, xp2, yp2 );
        }
        return result;
    }
\end{lstlisting}

Так как мы теперь используем массив предрасчитанных значений, то нужно удостовериться, что мы 
не выходим за его границы (да и возможны разрывы при рисовании окружности), поэтому когда 
значение переменной \( i \) является последним, то мы замыкаем нашу окружность выбирая 
первую точку в массиве. 

\section{Линия}
Как вы могли заметить, что для рисовании линии в SDL2 используется функция:
\[ 
    SDL\_RenderDrawLine 
\]
в которую мы передаём значения начальных и конечных координат линии и контекст рендера. Но есть 
одна проблема: рисуемая линия получается с зазубринами, что не очень хорошо. Советую почитать 
информацию по алгоритму Брезенхэма. Для рисования более сглаженной линии нам нужно использовать 
модификацию данного алгоритма, который использует альфа-канал. К счастью нам не нужно ничего 
изобретать, что реализовано уже за нас в библиотеке SDL2\_gfx: 
\url{http://cms.ferzkopp.net/index.php/software/13-sdl-gfx}.

Модифицированный код функции для рисования гладкой линии доступен в разделе \ref{code:aaline}.

\pagebreak

Теперь мы можем модифицировать код рисующий окружность заменив функцию рисования линии:
\lstinputlisting[firstline=115, lastline=134]{../game/02_minimal/src/draw.cpp}

И получим следующую картинку:
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.47\textwidth]{circle_02}
    \caption{Пример рисования нескольких окружностей разного радиуса (сглаженный вариант)}
    \label{img:AAcircleExample}
\end{figure}

\pagebreak

\section{Прочие функции DrawSystem}
Остались только вспомогательные функции по работе с цветом и работа с рендер контекстом. 
Они не являются чем-то сложным, поэтому просто предоставлю код для анализа читателю.

\lstinputlisting[firstline=19, lastline=49]{../game/02_minimal/src/draw.cpp}

\pagebreak

\section{Шрифт}
Вариаций создания и использования шрифтов огромное количество: от тайловых шрифтов до 
TrueType и векторных. В данном разделе остановимся одним вариантом: тайловый шрифт.
Сразу предоставлю картинку иллюстрирующую шрифт используемой для игры:
\begin{figure}[ht!]
    \centering
    \includegraphics{font}
    \caption{Тайловый шрифт с ограниченным алфавитом}
    \label{img:tileFont}
\end{figure}

Данный шрифт организован в виде блоков размером \( 16\times16 \). В одном блоке находится 
только один символ. Для кодирования алфавита создан отдельный конфигурационный файл с 
параметрами шрифта, имеющий следующую структуру
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth]{font_file}
    \caption{Структура файла конфигурации}
    \label{img:fontFile}
\end{figure}
\begin{itemize}\itemsep-5pt
    \item[A] -- размер строкового параметра C (\emph{unsigned int})
    \item[B] -- размер алфавита F (\emph{unsigned int})
    \item[C] -- имя разгружаемой картинки (\emph{char *})
    \item[D] -- ширина блока (\emph{int})
    \item[E] -- высота блока (\emph{int})
    \item[F] -- алфавит в формате utf-8
\end{itemize}

\pagebreak

Давайте сначала определим шаблон класс для работы с шрифтом.
\lstinputlisting[firstline=8, lastline=41]{../game/02_minimal/src/font.hpp}

Здесь \( ft \) структура для хранения данных о текстуре. Перечисление \emph{font\_error} 
отвечает за код ошибки, которые могут быть возвращены при выполнение функций. Класс 
FontTable состоит из: конструктор, деструктор, функции загрузки \emph{load}, 
функции рисования \emph{draw} и нескольких вспомогательных \emph{reload} \ldots 
\emph{get\_width}.

Давайте теперь опишем общую схему загрузки нашей картинки-шрифта:
\begin{enumerate}\itemsep-5pt
    \item прочитать файл конфигурации (перечисленные параметры)
    \item загрузить текстуру в память
    \item проиндексировать буквы с их местами на картинке
\end{enumerate}

Рассмотрим подробнее по пунктам ссылаясь на код. Начнём с первого пункта: всё довольно 
тривиально -- сводится к чтению данных из файла с выделением памяти под эти данные
\lstinputlisting[firstline=27, lastline=45]{../game/02_minimal/src/font.cpp}

Далее мы загружаем нашу текстуру в память и получаем её размеры (ширина и высота).
\lstinputlisting[firstline=46, lastline=56]{../game/02_minimal/src/font.cpp}

Ну и под конец главный цикл индексации букв: мы вносим в массив по индексу буквы значение 
её номера в текстуре.
\lstinputlisting[firstline=58, lastline=65]{../game/02_minimal/src/font.cpp}

Далее идёт закрытие файла и возврат успешного завершения функции. Далее рассмотрим подробнее 
механизм рисования текстуры в контексте рендера. 

\pagebreak

Общую схему рисования текста вы можете видеть далее:
\begin{enumerate}\itemsep-5pt
    \item получить строку с текстом
    \item получить букву
    \item найти её в текстуре
    \item нарисовать букву
    \item сдвинуть указатель далее по строке
    \item повторить пункт 2 пока не закончится текст
\end{enumerate}

Для того чтобы рисовать часть из текстуры мы должны будем выбирать координаты квадрата на 
текстуре и переносить её на наш контекст рендера. Делается это с помощью конструкции 
\emph{SDL\_Rect}. Так же нам понадобиться несколько переменных для хранения текущего 
положения блока отрисовки. Всё это можно проиллюстрировать следующим кодом

\lstinputlisting[firstline=73, lastline=80]{../game/02_minimal/src/font.cpp}

А далее мы будем обрабатывать нашу строку с текстом в цикле и рисовать каждую букву 
поблочно\footnote{Стоит только отметить, что в данном коде специальные символы обрабатываются 
в блоке \emph{switch-case} с некоторыми небольшими особенностями, которые способствуют 
производительности отрисовки}.
\lstinputlisting[firstline=81, lastline=116]{../game/02_minimal/src/font.cpp}

Оставшиеся вспомогательные функции: деструктор, \emph{reload} и 
\emph{set\_coloru} имеют простую структуру рассмотрение которой оставляется читателю.

Как результат получаем:
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.47\textwidth]{font_example}
    \caption{Пример рисования текста}
    \label{img:fontExample}
\end{figure}

\section{Заключение}
В данном разделе мы рассмотрели основные функции, которые используются для работы с 
графикой в игре Asteroids. Сделали небольшие оптимизации в коде и рассмотрели основные моменты 
связанные с графикой в SDL2. В следующем разделе мы напишем простую звуковую систему, которую 
будем использовать в игре. 

\chapter{Работа со звуком}
\section{Инициализация}
\section{Воспроизведение}

\chapter{Создание прототипа}
\section{Рисование}
\section{Движение}
\section{Физика}
\section{Рейтинг, бонусы и прочее}

\chapter{Справка}

\section{Исходный код}
Исходный код данного мануала и реализованной игры доступны по следующим ссылкам:\\
\url{https://github.com/FreeCX/study/tree/master/cad-fac/it/manual}\\
\url{https://github.com/FreeCX/study/tree/master/cad-fac/it/game/02_minimal}

\subsection{Скелет программы на SDL2}
\label{code:skeletonSDL2}
\lstinputlisting{../game/01_init/src/sdl2_init.cpp}

\pagebreak

\subsection{Скелет программы на GLUT}
\label{code:skeletonGLUT}
\lstinputlisting{../game/01_init/src/glut_init.cpp}

\pagebreak

\subsection{Класс vec2}
\label{code:vec2}
\begin{center}
    Заголовочный файл \emph{math.hpp}
\end{center}
\lstinputlisting{../game/02_minimal/src/math.hpp}

\pagebreak

\begin{center}
    Исходный код \emph{math.cpp}
\end{center}
\lstinputlisting{../game/02_minimal/src/math.cpp}

\pagebreak

\subsection{Функция aaline}
\label{code:aaline}
\begin{center}
    Исходный код функции aaline
\end{center}
\lstinputlisting[firstline=49, lastline=113]{../game/02_minimal/src/draw.cpp}

\pagebreak

\section{Полезные ресурсы разработчику}
Если у вас в команде нет художников или музыкантов, или вам нужно узнать определенные подробности по работе 
с тем или иным инструментом, то во многих случаях можно воспользоваться помощью интернета. Заказать у 
художника арты, у композитора фоновую музыку или обсудить тонкий вопрос по использования специфичного 
алгоритма, то в данном случае лучшим решением будет обратиться к следующим интернет источникам.

\begin{itemize}\itemsep-5pt
    \item FAQ по геймдизайну \url{http://www.sloperama.com/advice.html}
    \item Авторский блог Антона Карпова по разработке игр \url{http://www.ant-karlov.ru/}
    \item Аналог stackoverflow по gamedev \url{http://gamedev.stackexchange.com/}
    \item Блог посвященный созданию 2D графики\\
        \url{http://2dgameartforprogrammers.blogspot.ru/}
    \item Блог Райана Швайдера по gamedesign \url{http://www.nerfbat.com/lessons/}
    \item Источник свободных игровых ресурсов (CC0) \url{http://opengameart.org/}
    \item Крупнейшее сообщество модостроителей \url{http://moddb.com/}
    \item Крупные сообщества по игрострою \url{http://www.gamedev.ru/} (rus) и\\
        \url{http://www.gamedev.net/} (eng)
    \item Любительские конкурсы по разработке игр \url{http://igdc.ru/}
    \item Новости индустрии, блоги разработчиков и многое другое \url{http://gamasutra.com/}
    \item Сайт для специалистов по компьютерной графике \url{http://devmaster.net/}
    \item Сайт посвященный pixelart \url{http://www.pixeljoint.com/}
    \item Уроки по созданию 3D \url{http://www.digitaltutors.com/}
    \item Игровые спрайты старый игр \url{http://www.videogamesprites.net/}
    \item Свободный игровой контент \url{http://freegamearts.tuxfamily.org/}
    \item База свободных звуков \url{http://www.freesound.org/}
    \item Открытый музыкальный архив \url{http://www.openmusicarchive.org/}
    \item Базы 3D моделей \url{http://www.katorlegaz.com/3d_models/index.php}\\
        \url{https://3dwarehouse.sketchup.com/}
    \item CG текстуры \url{http://www.cgtextures.com/}
    \item Свободные архивы по текстурам \url{http://www.mayang.com/textures/}\\
        \url{http://www.texturearchive.com/}
    \item Библиотеки шрифтов \url{http://openfontlibrary.org/}\\
        \url{https://www.acidfonts.com/}
    \item Хабрахабр \url{http://habrahabr.ru}
    \item Invent Your Own Computer Games with Python\\
        \url{https://inventwithpython.com/chapters/}
    \item Making Games with Python \& Pygame\\
        \url{https://inventwithpython.com/pygame/chapters/}
    \item Sylvester,~T. Designing Games: A Guide to Engineering Experiences. O'Reilly Media, 2013
    \item Nystrom,~R. Game Programming Patterns \url{http://gameprogrammingpatterns.com/}
\end{itemize}