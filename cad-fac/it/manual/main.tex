\chapter{Проектирование игровой программы}
\section{Введение}

В данном методическом руководстве я не буду давать информацию по установке и настройке компиляторов и сред 
разработки, так же как и советовать использовать конкретный язык программирования. Я попытаюсь изложить 
некоторые тонкости в разработке структуры игровых программ: частые ошибки, возможные проблемы и на что стоит 
обратить внимание при проектировании и разработке.

Примеры в основном будут на языке C++ с использованием следующих библиотек:
\begin{itemize}
    \item SDL2
    \item OpenGL
    \item GLUT
    \item OpenAL
    \item vorbis
\end{itemize}

Я глубоко надеюсь что прежде чем разрабатывать игру читатель определил для себя: \emph{идею}, \emph{жанр}, 
\emph{история}, \emph{стиль}, \emph{игровая механика} разрабатываемой игры. Но не стоит расстраиваться если 
у вас нет ещё идеи для игры -- давайте вместе шаг за шагом рассмотрим и напишем римейк старой игры под 
названием Asteroids.

С чего начинается проектирование игры? Обычно всё начинается с идеи. Наверное самый важный компонент любой 
игры. Конечно она может быть не столь яркой и интересной, но определив игровую механику можно сгладить этот 
изъян и получить довольно интересную и яркую игру. Немаловажным является то, что если у разрабатываемой игры 
появляется своя история и неповторимый стиль, которые только развивают идею и улучшают возникающие 
впечатления от игры.

Но не будем философствовать на этот счёт и подойдём с другой стороны -- с технической. Для того чтобы начать
разрабатывать игру с нуля нам нужен некоторый \emph{скелет} (в другом случае -- использовать функции 
используемого фреймворка).

\pagebreak

\section{Проектирование структуры игры}
Если говорить в общем, то самую простую структуру можно представить следующей блок-схемой 
(рис.~\ref{img:skeleton}). На этом простом \emph{скелет} мы и разработаем игровую программы. Конечно 
используемые \emph{скелеты} в профессиональной сфере могут (и будут) иметь более сложную структура, но для 
разработки простых игр, нам хватит и данной структуры.

Давайте рассмотрим каждый шаг в этой схеме. \textbf{Инициализация} -- блок подготовки и предварительной 
обработки игровых данных. Это может быть пред-/загрузка графических, звуковых и конфигурационных файлов. 
Список может быть и больше, в зависимости от конкретного типа игры: игровые карты, получение информации с 
игрового сервера, генерация параметров игровых предметов и многое другое. Говоря в общем -- это подготовка 
данных для игры.

\begin{wrapfigure}[18]{r}{0.22\linewidth}
    \includegraphics[width=0.2\textwidth]{game_loop}
    \caption{Структура игрового цикла}
    \label{img:skeleton}
\end{wrapfigure}

Блок \textbf{обработки событий} в основном отвечает за работу с оконной системой, т.е. нажатая клавиша, 
передвинутый курсор, изменение размера окна программы и прочие события связанные с окном программы в 
операционной системе. 

Далее у нас по списку -- \textbf{игровой цикл}. Проводя аналогию с предыдущим блоком, то этот блок делает 
тоже самое, но для нашей игры -- двигает персонажей, обрабатывает игровые события и многие другие вещи, 
которые нам нужны в играх. Этот блок можно конечно разделить на много мелких, которые отвечают за отдельные 
части игровой программы, но мы остановимся на более общем виде. 

Ну и последнее в цикле это \textbf{рендеринг} -- основная часть структуры программы, без которой мы не могли 
бы представить пользователю графическую часть нашей игры. Всё что связано с обработкой и отрисовкой графики 
располагается здесь: от шейдеров до рисования точки на экране.

Внимательный читатель мог заметить и сказать: -- А где собственно работа со звуком? И он будет прав, в нашей 
структуре отсутствует звуковая система! Если быть честным, то звуковая система должна быть идти сразу после 
инициализации, но для того чтобы мы не слышали обрывки в воспроизведении звука она должна идти отдельным 
потоком. Таким образом звуковая система будет работать параллельно нашему циклу и не зависеть от его скорости 
выполнения. Также можно сказать, что стоит выносить в отдельный поток и рендеринг, так как при во многих 
случаях нужно обеспечивать приемлемую скорость его работы, а в данном потоке это не является возможным. Но 
так как наша игра не будет столь требовательной к скорости работы, то мы можем оставить всё как есть.

И наконец последний блок \textbf{деинициализация} -- освобождение выделенных в первом блоке ресурсов и 
устройств. Важный блок с точки зрения работы с памятью.

\pagebreak

\section{Программная реализация скелета}
Давайте напишем \emph{скелет} программы шаг за шагом на примере работы с двумя разными библиотеками SDL2 и 
GLUT.

Для начала нам нужно выделить основные блоки, которые будут одинаковы в каждой программе независимо от 
используемой библиотеки, а также не забываем о предыдущем пункте, где мы рассматривали структуру типичной 
игровой программы.

\begin{lstlisting}
    void game_init( void ) { // инициализация }
    void game_event( void ) { // обработка событий }
    void game_loop( void ) { // игровой цикл }
    void game_render( void ) { // функция рендеринга }
    void game_destroy( void ) { // деинициализация }
    int main( int argc, char * argv[] ) {
        // точка входа в программу
        return EXIT_SUCCESS;
    }
\end{lstlisting}

Данный код больше подходить к использованию с библиотекой SDL2, в тоже время библиотека GLUT требует 
объявления \emph{callback}-функций, которые будут обрабатывать определённые события. Как пример приведу 
изменения, которые нужно совершить, чтобы удовлетворить программную архитектуру библиотеки GLUT.

\begin{lstlisting}
    void game_init( void ) { // инициализация }
    void game_...( <params> ) { // callback функции }
    void game_loop( int value ) { // игровой цикл }
    void game_render( void ) { // функция рендеринга }
    void game_destroy( void ) { // деинициализация }
    int main( int argc, char * argv[] ) {
        // точка входа в программу
        return EXIT_SUCCESS;
    }
\end{lstlisting}

Троеточием показано, что название функции будет зависеть от того, что мы хотим использовать: обработку 
событий от клавиатуры, мыши, окна и прочие. Давайте в текущем примере используем обработчик клавиатуры, но 
для этого определим параметры, которые нам будут нужны для работы с окном.

SDL2:
\lstinputlisting[firstline=3, lastline=13]{../game/01_init/src/sdl2_init.cpp}

\pagebreak

GLUT:
\lstinputlisting[firstline=3, lastline=10]{../game/01_init/src/glut_init.cpp}

Основные параметры на которые стоит обратить внимание: \textbf{name} -- имя окна, \textbf{width} -- ширина, 
\textbf{height} -- высота. Это постоянные параметры, которые не будут меняться, а остальные зависят от 
используемой библиотеки. В случае с SDL2: \textbf{window} -- идентификатор окна, \textbf{render} -- контекст 
отрисовщика, \textbf{event} -- структура хранящая оконные события. Для GLUT пока только одно специфическое 
\textbf{win\_id} -- идентификатор окна.

Теперь можно перейти к определению функции обработки событий клавиатуры.

GLUT:
\lstinputlisting[firstline=25, lastline=38]{../game/01_init/src/glut_init.cpp}

В данном отрывке кода представлено два события: закрытие окна по нажатию на клавишу 'q' и переключение между 
режимами экрана 'f'.

Основные функции:
\begin{itemize}\itemsep-5pt
    \item glutDestroyWindow( GLint window\_handle ) -- уничтожение окна по идентификатору
    \item glutFullScreen( GLvoid ) -- переход в полноэкранный режим
    \item glutReshapeWindow( GLint width, GLint height ) -- изменение размера окна
\end{itemize}

Далее рассмотрим использование каждой библиотеки по отдельности.

\pagebreak

\subsection{SDL2}
Давайте постепенно функция за функцией опишем \textbf{скелет} программы. Первое с чего начнём -- функция 
обработки ошибок. В дальнейшем она нам будет очень полезна, да и пользователь сможет понять что случилось при 
экстренном закрытии программы.

\lstinputlisting[firstline=15, lastline=20]{../game/01_init/src/sdl2_init.cpp}

Библиотечная функция \emph{SDL\_ShowSimpleMessageBox} принимает несколько параметров на вход, а именно:
\begin{enumerate}\itemsep-5pt
    \item тип икона
    \item заголовок окна
    \item выводимое сообщение
    \item тип используемых кнопок (если ноль или \textbf{nullptr}, то кнопка OK)
\end{enumerate}

Код прозрачен и прост -- в случае ошибки мы выводим её на экран, а далее закрываем программы с 
соответствующим кодом. 

Идём далее и реализуем код для точки входа в программу используя рис.~\ref{img:skeleton}.
\lstinputlisting[firstline=87, lastline=98]{../game/01_init/src/sdl2_init.cpp}

Главное на что стоит обратить внимание, так это параметр \textbf{quit\_flag}, который будет сигнализировать 
нам о закрытии программы. В остальном всё соответствует рис.~\ref{img:skeleton}.

Теперь пойдём последовательно по блокам и опишем каждый из них. Начнём с рассмотрения псевдокода, а потом 
рассмотрим на примере работающего кода.

Всё что нужно, чтобы инициализировать систему на данном этапе, так это несколько шагов:
\begin{enumerate}\itemsep-5pt
    \item инициализировать SDL2
    \item создать окно
    \item создать контекст отрисовщика
    \item обработать предыдущие шаги на ошибки
\end{enumerate}

\newpage

Так давайте сделаем это:
\lstinputlisting[firstline=68, lastline=85]{../game/01_init/src/sdl2_init.cpp}

Подробности по ссылке \url{https://wiki.libsdl.org/}.

\begin{itemize}\itemsep-5pt
    \item SDL\_Init -- инициализация систем SDL2 (видео, аудио, клавиатура \ldots)
    \item SDL\_CreateWindow -- создание окна приложения
    \item SDL\_CreateRender -- функция инициализации контекста отрисовщика
\end{itemize}

Блоки, где производятся сравнения с нулевым указателем -- это обработка ошибок.

Далее следует блок обработки событий. На этапе проектирования он будет иметь минимальный функционал:
\begin{itemize}\itemsep-5pt
    \item обработка закрытия программы
    \item обработка изменения размера окна
    \item шаблон для обработки нажатия клавиш
\end{itemize}

В программном коде это будет выглядеть так:
\lstinputlisting[firstline=22, lastline=47]{../game/01_init/src/sdl2_init.cpp}

При вызове данной функции происходит следующее: с помощью \emph{SDL\_PollEvent} мы запрашиваем текущее 
событие от системы SDL2, а далее с помощью конструкции \textbf{switch-case} выбираем соответствующую ветку 
для обработки. Всего их сейчас три, не считая \textbf{default}. 

Первая \emph{SQL\_QUIT} -- отвечает за обработку события выхода из программы -- в нашем случае это установка 
булевой функции в значение \textbf{true}, что обеспечит нам выход из основного цикла.

Вторая \emph{SDL\_WINDOWEVENT} и \emph{SDL\_WINDOWEVENT\_RESIZED} отвечают за изменение размеров окна и 
соответствующее внесение изменения в параметры нашей структуры (\emph{gw.width} и \emph{gw.height}).

И последнее событие \emph{SDL\_KEYDOWN} отвечающее за нажатие клавиш. В данном случае нам нужно ещё узнать 
какая именно клавиша была нажата (\emph{gw.event.key.keysym.sym}) и соответственно как-то отреагировать на 
это. В нашем случае это обработка клавиши \emph{Esc} и установка флага выхода в значение \textbf{true} 
(ещё один способ закрытия окна по событию).

На текущий момент момент это всё, что нужно для работы обработчика событий в нашей программе, но нам также 
нужно будет обрабатывать события отжатия клавиш \emph{SDL\_KEYUP}, но его мы разберём подробно при 
разработке игры.

Следующий три немаловажный блока -- игровой цикл, рендеринг и деинициализация. Мы рассмотрим их вместе, так 
как они сейчас имеют наименьший объём кода и являются просто заглушками в программе.
\lstinputlisting[firstline=49, lastline=66]{../game/01_init/src/sdl2_init.cpp}

Выглядит довольно просто не так ли? Остановимся на отрисовщике и функции деинициализации подробнее.

Чтобы наша программа могла рисовать в поле \emph{renderer} нужно его подготовить функцией 
\emph{SDL\_RenderClear}, которая очищает предыдущий кадр и заливает поле отрисовки в установленный цвет 
(по стандарту чёрный). Далее мы можем производить любые действия с ним. В конце отрисовки мы должны 
перенести все произведённые манипуляции на экран, чем и занимается функция \emph{SDL\_RenderPresent}.

Для деинициализации окна нам нужно проделать несколько простых действий:
\begin{itemize}\itemsep-5pt
    \item освободить контекст рендера: \emph{SDL\_DestroyRenderer}
    \item закрыть окно созданное SDL2: \emph{SDL\_DestroyWindow}
    \item выйти из программы: \emph{SDL\_Quit}
\end{itemize}

На этом наша заготовка готова к работе. Полный код можно посмотреть в разделе \ref{code:skeletonSDL2}

\subsection{GLUT}
С библиотекой GLUT дела обстоят похожим образом. Отличия состоят в способе организации обработки событий.
В основном GLUT использует \textbf{callback} функции для организации псевдо-ООП подход. Удобный подход, но 
требующий организации более своеобразной структуры работы, но имеющий главный плюс -- работа в отдельных 
потоках (рендеринг, обработка событий и т.д.), что хорошо влияет на общую производительность программы 
(в отличии от последовательной обработки всех событий). Рассмотрим также основные блоки формирующие 
программу.

Начнём с точки входа в программу:
\lstinputlisting[firstline=59, lastline=66]{../game/01_init/src/glut_init.cpp}

Здесь всё довольно просто, за исключением отсутствия игрового цикла (как в программе с SDL2). Ну давайте 
пойдём по порядку.
\begin{itemize}\itemsep-5pt
    \item glutInit -- функция инициализации GLUT среды
    \item game\_init -- наша функция инициализации
    \item glutMainLoop -- функция отвечающая за обработку событий GLUT (эта функции никогда не возвращается, 
        наша программа по существу входит в бесконечный цикл)
    \item game\_destroy -- наша функция деинициализации
\end{itemize}

Теперь перейдём к инициализации. Используя GLUT на нужно произвести некоторые действия, для того чтобы 
создать окно с контекстом для рисования, плюс нужно указать какие мы будем использовать callback-функции 
в нашей программе. Выделим необходимые действия, которые нужно совершить

\newpage

\begin{itemize}\itemsep-5pt
    \item создать окно
    \item определить функцию рендеринга
    \item определить функцию обработки событий клавиатуры
    \item произвести настройку OpenGL контекста
\end{itemize} 

Теперь реализуем данные действия в коде:
\lstinputlisting[firstline=40, lastline=52]{../game/01_init/src/glut_init.cpp}

Строки с 3 по 8 отвечают за создание окна, а именно:
\begin{itemize}\itemsep-5pt
    \item[3-4] получение размера экрана
    \item[5-6] установка размера окна и его положения
    \item[7] установка параметров контекста для отрисовки 
        (RGBA палитра и использование двойной буферизации)
    \item[8] создание окна
\end{itemize}

Далее идут функции:
\begin{itemize}\itemsep-5pt
    \item glutDisplayFunc которая получает callback-функцию нашего рендера
    \item glutKeyboardFunc которая получает callback-функцию нашего обработчика клавиатуры
    \item glutTimerFunc -- функция таймера, которая будет вызывать game\_loop с заданным интервалом
\end{itemize}

И под конец OpenGL функция \emph{glClearColor}, которая устанавливает цвет очистки экрана.

Функцию обработки клавиатуры имеет очень простую структуру в основе. При её вызове, ей передаётся значение 
нажатой кнопки. В зависимости от её кода, мы выбираем то или иное действие (мы рассмотрели работу кода ранее).

Последние несколько функции рассмотрим вместе. Функция освобождения ресурсов в нашем случае будет только 
заглушкой, поэтому текущий код будет выглядеть так:
\lstinputlisting[firstline=54, lastline=57]{../game/01_init/src/glut_init.cpp}

И ещё остаётся две функции, которые будут получаются связанными
\lstinputlisting[firstline=12, lastline=23]{../game/01_init/src/glut_init.cpp}

В функции отрисовки всё довольно тривиально: с помощью функции \emph{glClear} очищаем предыдущее состояние 
окна, выполняем свои действия и под конец вызываем функцию \emph{glutSwapBuffers}, которая меняет буферы 
отрисовки местами и выводит картинку на экран.

Функция отвечающая за игровой цикл отвечает как за вызов функции отрисовки, так и за обработку игровых 
событий. Но главный минус заключается в том что нам нужно каждый раз вызывать функцию таймер, который 
будет вызывать функцию игрового цикла.

\subsection{Заключение}
Мы рассмотрели две различных технологии: GLUT (с контекстом отрисовки OpenGL) и SDL2 (со стандартным 
контекстом отрисовки). Далее будем использовать SDL2, так как:
\begin{itemize}\itemsep-5pt
    \item имеет более свежую базу кода
    \item он более прост в работе
    \item большой функционал с поддержкой <<из коробки>>
    \item есть возможность выбора драйвера отрисовщика (OpenGL, software и другие)
\end{itemize} 

\pagebreak

\section{Игровая механика}

Давайте теперь перейдём непосредственно к разработке игры <<Asteroids>>. Поиграть в игру можно на сайте 
\url{http://www.freeasteroids.org}, где собственно можно понять основные моменты игровой механики данной 
игры.

Давайте определимся с объектами, которые задействованы в игре:
\begin{itemize}\itemsep-5pt
    \item корабль игрока
    \item астероиды
    \item снаряды игрока
\end{itemize}

Это основные объекты, которые присутствуют в данной игре. Давайте более подробно рассмотрим каждый объект 
более пристально и опишем их.

\subsection{Игрок}
Корабль игрока -- главный персонаж данной игры. Он обладает несколькими основными действиями:
\begin{itemize}\itemsep-5pt
    \item выстрелить снаряд по направлению
    \item повернуть корабль относительно его центра
    \item передвинуть корабль по направлению
\end{itemize}

Отсюда мы можем выделить основные параметры, которые нам будут нужны для его проектирования: координаты 
центра, угол поворота, скорость и количество жизней. Ещё стоит заметить, что игровой экран имеет зацикленную 
структуру: то есть если мы летим в право, то при пересечении границы игрового поля мы вылетим с левой стороны 
и соответственно и с верхом и низом. Но при определении базовой структуры класса игрока данный функционал 
нам не требуется, поэтому при реализации движения игрока рассмотрим данную возможность подробнее. Давайте 
теперь реализуем нашу структуру в коде\footnote{Вы можете заметить незнакомый (ну или неопределённый) класс 
\emph{vec2} -- это двумерная система координат, которая будет использоваться в данном проекте. Код и 
заголовочный файл приложены в разделе \ref{code:vec2}.}.
\begin{lstlisting}
    class Player {
    public:
        Player() : p( vec2( 0.0f, 0.0f ) ), life( 3 ), 
                   velocity( 0.0f ), angle( 0.0f ) {}
    private:
        vec2 p; // векторное представление координат корабля
        short life; // количество жизней
        float velocity, angle; // скорость и угол поворота
    };
\end{lstlisting}

Это только базовый шаблон для игрового корабля. Нам также нужно будет сюда добавить несколько дополнительных 
функций, которые будут отвечать за отрисовку, передвижение, столкновение и прочие вспомогательные функции 
в игре, но рассмотрение и реализацию отложим на последующие главы.

\subsection{Астероиды}
Астероиды в игре можно представить в виде группы объектов, которые будут управляться базовым классом. У них 
не так много возможностей: движение в заданном направлении. Чтобы наша игра была более живой и интересной мы 
добавим астероидам: угловую скорость и возможность сталкиваться друг с другом. Каждый астероид можно 
охарактеризовать некоторым набором параметров: позиция, скорость, радиус, угловая скорость и угол. Давайте 
же опишем базовый класс.
\begin{lstlisting}
    #include <vector>

    typedef struct {
        vec2 p, v; // позиция и скорость
        int radius; // радиус
        float angle, rotate; // угол и угловая скорость
    } asteroid_t;

    typedef std::vector< asteroid_t > asteroid_v; 

    class AsteroidSystem {
    public:
        AsteroidSystem( const int width, const int height, 
                        const int asteroid_count, const int segment_count );
        ~AsteroidSystem();
    private:
        void collide( int i, int j );
        asteroid_v asteroids;
        int asteroid_count;
        int segment_count;
        float * segments;
        int * pos;
        float * dist;
    };
\end{lstlisting}

В данном коде мы определили структуру описывающую один астероид и класс, который будет управлять всеми 
созданными астероидами. Пока описан только конструктор в который передаётся значения размера игровой комнаты, 
количество астероидом и количество сегментов на них (да их детализации) и пустой деструктор. Также среди 
параметров будем хранить количество астероидом и количество их сегментов, а также несколько массивов:
\begin{itemize}\itemsep-5pt
    \item segments -- массив для хранения координат круга
    \item pos -- вспомогательная структура для хранения промежуточных данных
    \item dist -- массив для хранения неровностей астероида
\end{itemize} 
Более подробно остановимся на этих параметрах, когда будем рассматривать раздел работы с графикой.

И последнее -- функция \emph{collide} которая будет обрабатывать столкновения между астероидами.

\subsection{Снаряды}
Для описания снарядов нам понадобиться всего несколько параметров: позиция, время жизни, угол и скорость.
Как и в прошлом пункте, нам нужна система, которая будет управлять всеми снарядами. Поэтому мы выделим 
эти пункты в структуру, а класс уже будет иметь доступ ко всему массиву. Опишем данную структуру в коде.

\begin{lstlisting}
    #include <vector>

    typedef struct {
        vec2 p; // позиция
        short life; // время жизни
        float angle, velocity; // угол и скорость
    } bullet_t;

    typedef std::vector< bullet_t > bullet_v;

    class BulletSystem {
    public:
        BulletSystem( const float velocity, const short life, const short radius );
        ~BulletSystem();
    private:
        bullet_v bullets;
        // стандартные значения для
        float max_velocity; // скорости
        short max_life; // времени жизни
        short max_radius; // радиуса
    };
\end{lstlisting}

Как видно из класса управляющего снарядами мы имеем конструктор принимающий значения скорости, времени жизни 
и радиуса снаряда, которые будут создаваться во время игры и пока пустой деструктор. Также мы здесь указали 
параметры в которых мы будем хранить данные принятые конструктором, ну и массив для хранения самих снарядов.

\subsection{Заключение}
На данном этапе мы сделали минимальное описание структуры наших игровых объектов. Пока мы не объявили 
функции отвечающие за рисование самих объектов, обработку столкновений и остального функционала, но уже 
заложили основу для проектирования игры. В следующих разделах мы рассмотрим работу с графикой и звуком, а 
также напишем их реализацию, которая нам понадобиться в игре.

\pagebreak

\chapter{Работа с графикой}
В данной главе мы рассмотрим и реализуем модуль минимальным функционалом для работы с графикой. 
Всё что нужно нам для создания игры это:
\begin{itemize}\itemsep-5pt
    \item цвет
    \item линия
    \item круг
    \item шрифт
\end{itemize}

Но прежде чем мы начнём с реализации давайте определим класс (назовём его DrawSystem), который будет отвечать 
за работу с графикой. DrawSystem должен включать в себя следующие функции:
\begin{itemize}\itemsep-5pt
    \item конструктор
    \item деструктор
    \item функции для работы с цветом
    \item функция рисования круга
    \item функция рисования линии
\end{itemize}

Следующий код определяет наши требования:
\lstinputlisting[firstline=16, lastline=31]{../game/02_minimal/src/draw.hpp}

Отметим несколько особенностей данного кода: нам требуются такие переменные как область для рисования 
(render), массив для хранения единичной окружности (coords) и количество сегментов в данной окружности 
(segments). Если с \emph{render} более-менее может быть понятно, то для чего нужны \emph{coords} и 
\emph{segments}? Давайте рассмотрим как рисуется окружность.

\section{Окружность}
Давайте сразу приступим к математической части. Окружность можно описать следующим уравнение в декартовой 
системе координат:
\[
    x^2 + y^2 = r^2
\]
где \( x \) и \( y \) -- декартовы координаты, а \( r \) -- радиус окружности.

Но так уж сложилось, что нам для рисования нужно знать координаты, поэтому данная формула нам не очень 
подходит. Стоит посмотреть в сторону параметрических уравнений:
\[
    \left\{ \begin{array}{l}
        x = x_0 + r \cdot \cos\phi \\
        y = y_0 + r \cdot \sin\phi 
    \end{array} \right., 0 \leq \phi < 2\pi
\]

Данная формула уже намного удобнее, так как нам нужно изменять всего лишь один параметр \( \phi \), для того 
чтобы нарисовать окружность. Заметим сразу следующее, что мы будем рисовать окружность как набор линий 
(или сегментов), т.е. нам нужно сразу определять четыре координаты. 

Реализацию данного метода можно проиллюстрировать следующим кодом:
\begin{lstlisting}
    int DrawSystem::circle( int x, int y, int r ) {
        float dphi = 2.0f * M_PI / 20; // размер сегмента окружности
        float xp1, yp1, xp2, yp2;
        int result = 0; // результат выполнения кода

        for ( float phi = 0; phi < 2.0f * M_PI; phi += dphi ) {
            xp1 = x + r * cos( phi ); 
            yp1 = y + r * sin( phi );
            xp2 = x + r * cos( phi + dphi );
            yp2 = y + r * sin( phi + dphi );
            result |= SDL_RenderDrawLine( render, xp1, yp1, xp2, yp2 );
        } 
        return result;
    }
\end{lstlisting}

\pagebreak

В результате мы получим, что-то в этом виде:
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.47\textwidth]{circle_01}
    \caption{Пример рисования нескольких окружностей разного радиуса}
    \label{img:circleExample}
\end{figure}

Получилось довольно не плохо, если не учитывать что мы при рисовании каждой окружности должны считать 
значения \( \sin \) и \( \cos \) каждый раз, что не есть хорошо. Ещё одним минусом является, что окружность 
рисуется с зазубринами -- это конечно не плохо, но можно сделать и сглаженный вариант, но давайте сначала 
разберёмся с начальным предварительным расчётом, а в следующем разделе поговорим про рисовании гладких линий.

Для того чтобы нам каждый раз не считать значения \( \sin \) и \( \cos \) мы можем на этапе инициализации 
нашего класса DrawSystem один раз их подсчитать для окружности единичного радиуса, а далее в коде всего лишь 
помножить на радиус. Предоставлю сразу код для конструктора и деструктора, который реализует данную 
функциональность\footnote{Данный код хранит значения \( x \) и \( y \) координаты в одном массиве. Обычно 
такой способ хранения данных используют для передачи данных OpenGL и многие другие библиотеки работающие с 
графикой.}:
\lstinputlisting[firstline=3, lastline=17]{../game/02_minimal/src/draw.cpp}

\newpage

И соответственно изменяем код рисующий окружность\footnote{Внимательный читатель может заметить, что теперь 
\( xp1, xp2, yp1, yp2 \) имеют тип \emph{int} и в коде используется функция \emph{round} -- это нужно для 
более точного рисования окружности без грубого перевода \emph{float} в \emph{int} путём отсечения дробной 
части}:
\begin{lstlisting}
    int DrawSystem::circle( int x, int y, int r ) {
        int xp1, xp2, yp1, yp2;
        int result = 0;

        // проходим по всем сегментам
        for ( size_t i = 0; i < segments * 2; i += 2 ) {
            xp1 = x + round( r * coords[i+0] );
            yp2 = y + round( r * coords[i+1] );
            if ( i == ( segments - 1 ) * 2 ) {
                xp2 = x + round( r * coords[0]   );
                yp2 = y + round( r * coords[1]   );
            } else {
                xp2 = x + round( r * coords[i+2] );
                yp2 = y + round( r * coords[i+3] );
            }
            result |= SDL_RenderDrawLine( render, xp1, yp1, xp2, yp2 );
        }
        return result;
    }
\end{lstlisting}

Так как мы теперь используем массив предварительно рассчитанных значений, то нужно удостовериться, что мы 
не выходим за его границы (да и возможны разрывы при рисовании окружности), поэтому когда значение 
переменной \( i \) является последним, то мы замыкаем нашу окружность выбирая первую точку в массиве. 

\section{Линия}
Как вы могли заметить, что для рисования линии в SDL2 используется функция:
\[ 
    SDL\_RenderDrawLine 
\]
в которую мы передаём значения начальных и конечных координат линии и контекст рендера. Но есть одна 
проблема: рисуемая линия получается с зазубринами, что не очень хорошо. Советую почитать информацию по 
алгоритму Брезенхэма. Для рисования более сглаженной линии нам нужно использовать модификацию данного 
алгоритма, который использует альфа канал. К счастью нам не нужно ничего изобретать, что реализовано уже 
за нас в библиотеке SDL2\_gfx: \url{http://cms.ferzkopp.net/index.php/software/13-sdl-gfx}.

Модифицированный код функции для рисования гладкой линии доступен в разделе \ref{code:aaline}.

\newpage

Теперь мы можем модифицировать код рисующий окружность заменив функцию рисования линии:
\lstinputlisting[firstline=115, lastline=134]{../game/02_minimal/src/draw.cpp}

И получим следующую картинку:
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.47\textwidth]{circle_02}
    \caption{Пример рисования нескольких окружностей разного радиуса (сглаженный вариант)}
    \label{img:AAcircleExample}
\end{figure}

\pagebreak

\section{Прочие функции DrawSystem}
Остались только вспомогательные функции по работе с цветом и работа с рендер контекстом. Они не являются 
чем-то сложным, поэтому просто предоставлю код для анализа читателю.
\lstinputlisting[firstline=19, lastline=49]{../game/02_minimal/src/draw.cpp}

\pagebreak

\section{Шрифт}
Вариаций создания и использования шрифтов огромное количество: от тайловых шрифтов до TrueType и векторных. 
В данном разделе остановимся одним вариантом: тайловый шрифт. Сразу предоставлю картинку иллюстрирующую 
шрифт используемой для игры:
\begin{figure}[ht!]
    \centering
    \includegraphics{font}
    \caption{Тайловый шрифт с ограниченным алфавитом}
    \label{img:tileFont}
\end{figure}

Данный шрифт организован в виде блоков размером \( 16\times16 \). В одном блоке находится только один 
символ. Для кодирования алфавита создан отдельный конфигурационный файл с параметрами шрифта, имеющий 
следующую структуру
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth]{font_file}
    \caption{Структура файла конфигурации}
    \label{img:fontFile}
\end{figure}
\begin{itemize}\itemsep-5pt
    \item[A] -- размер строкового параметра C (\emph{unsigned int})
    \item[B] -- размер алфавита F (\emph{unsigned int})
    \item[C] -- имя разгружаемой картинки (\emph{char *})
    \item[D] -- ширина блока (\emph{int})
    \item[E] -- высота блока (\emph{int})
    \item[F] -- алфавит в формате utf-8
\end{itemize}

\pagebreak

Давайте сначала определим шаблон класс для работы с шрифтом.
\lstinputlisting[firstline=8, lastline=41]{../game/02_minimal/src/font.hpp}

Здесь \( ft \) структура для хранения данных о текстуре. Перечисление \emph{font\_error} отвечает за код 
ошибки, которые могут быть возвращены при выполнении функций. Класс FontTable состоит из: конструктор, 
деструктор, функции загрузки \emph{load}, функции рисования \emph{draw} и нескольких вспомогательных 
\emph{reload} \ldots \emph{get\_width}.

Давайте теперь опишем общую схему загрузки нашей картинки шрифта:
\begin{enumerate}\itemsep-5pt
    \item прочитать файл конфигурации (перечисленные параметры)
    \item загрузить текстуру в память
    \item проиндексировать буквы с их местами на картинке
\end{enumerate}

Рассмотрим подробнее по пунктам ссылаясь на код. Начнём с первого пункта: всё довольно тривиально -- 
сводится к чтению данных из файла с выделением памяти под эти данные
\lstinputlisting[firstline=27, lastline=45]{../game/02_minimal/src/font.cpp}

Далее мы загружаем нашу текстуру в память и получаем её размеры (ширина и высота).
\lstinputlisting[firstline=46, lastline=56]{../game/02_minimal/src/font.cpp}

Ну и под конец главный цикл индексации букв: мы вносим в массив по индексу буквы значение её номера в 
текстуре
\lstinputlisting[firstline=58, lastline=65]{../game/02_minimal/src/font.cpp}

Далее идёт закрытие файла и возврат успешного завершения функции. Далее рассмотрим подробнее механизм 
рисования текстуры в контексте рендера. 

\pagebreak

Общую схему рисования текста вы можете видеть далее:
\begin{enumerate}\itemsep-5pt
    \item получить строку с текстом
    \item получить букву
    \item найти её в текстуре
    \item нарисовать букву
    \item сдвинуть указатель далее по строке
    \item повторить пункт 2 пока не закончится текст
\end{enumerate}

Для того чтобы рисовать часть из текстуры мы должны будем выбирать координаты квадрата на текстуре и 
переносить её на наш контекст рендера. Делается это с помощью конструкции \emph{SDL\_Rect}. Так же нам 
понадобиться несколько переменных для хранения текущего положения блока отрисовки. Всё это можно 
проиллюстрировать следующим кодом
\lstinputlisting[firstline=73, lastline=80]{../game/02_minimal/src/font.cpp}

А далее мы будем обрабатывать нашу строку с текстом в цикле и рисовать каждую букву поблочно\footnote{Стоит 
только отметить, что в данном коде специальные символы обрабатываются в блоке \emph{switch-case} с 
некоторыми небольшими особенностями, которые способствуют производительности отрисовки}.
\lstinputlisting[firstline=81, lastline=116]{../game/02_minimal/src/font.cpp}

Оставшиеся вспомогательные функции: деструктор, \emph{reload} и 
\emph{set\_coloru} имеют простую структуру рассмотрение которой оставляется читателю.

Как результат получаем:
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.47\textwidth]{font_example}
    \caption{Пример рисования текста}
    \label{img:fontExample}
\end{figure}

\section{Заключение}
В данном разделе мы рассмотрели основные функции, которые используются для работы с графикой в игре 
Asteroids. Сделали небольшие оптимизации в коде и рассмотрели основные моменты связанные с графикой в SDL2. 
В следующем разделе мы напишем простую звуковую систему, которую будем использовать в игре. 

\chapter{Работа со звуком}
В данном разделе мы рассмотрим и реализуем простую звуковую систему способную производить несколько простых 
действий: загрузка, воспроизведение, изменение громкости и остановка/пауза. В работе со звуком не будет 
сложных вещей, которые нужно будет запоминать. Вся документация по используемым библиотекам доступна в 
интернете. В данном проекте мы будем использовать две библиотеки: OpenAL (\url{http://www.openal.org/}) -- 
как прослойка между операционной системой и программистом и vorbis (\url{http://vorbis.com/}) -- библиотека 
предоставляющая доступ к легковесному контейнерному формату ogg. Эти библиотеки являются кроссплатформенными, 
что упрощает разработку. 

\section{Структура класса SoundSystem}
Начнём пожалуй с того, что определимся с методами, которые нам будут нужны в данном классе. Как ранее и 
упоминалось -- это загрузка, воспроизведение, изменение громкости и остановка/пауза, плюс к этому 
конструктор и деструктор. Давайте взглянем на код
\lstinputlisting[firstline=10, lastline=27]{../game/02_minimal/src/sound.hpp}

\pagebreak

Главной особенностью на которую стоит обратить внимание -- это все функции, кроме загрузки работают с 
некоторым параметром так называемым <<хэндлом>>. Он очень важен, так как будет указывать на тот звуковой 
файл, который мы хотим воспроизвести. Говоря кратко, то мы будем хранить все загруженные звуки в памяти и по 
необходимости их воспроизводить. Конечно такой подход не очень хорошо использовать, при большом количестве 
звуковых файлов, но в данном случае это не так, поэтому мы используем этот простой и лаконичный вариант.

Рассмотрим чуть подробнее следующие строки:
\lstinputlisting[firstline=24, lastline=26]{../game/02_minimal/src/sound.hpp}
\begin{enumerate}\itemsep-5pt
    \item отвечает за звуковой контекст устройства 2
    \item выбранное звуковое устройство в системе
    \item массив т.н. источников звука (по простому -- наши звуковые данные)
\end{enumerate}

Заканчивая рассмотрения структуры SoundSystem давайте непосредственно перейдём к коду.

\section{Кодовая база}
Начнём с рассмотрения устройства SoundSystem с конструктора. Опишем общие положения по инициализации 
звуковой системы
\begin{itemize}\itemsep-5pt
    \item открытие звукового устройства
    \item проверка доступности расширений
    \item создание звукового контекста
    \item настройка контекста
\end{itemize}

Проиллюстрируем данные пункты кодом:
\lstinputlisting[firstline=3, lastline=32]{../game/02_minimal/src/sound.cpp}

Все пункты, кроме настройки контекста должны быть просты и понятны. Настройка контекста подразумевается под 
настройкой положения слушателя и его ориентации в пространстве. Этот функционал нам на текущий момент не 
сильно нужен, поэтому мы устанавливаем все параметры в постоянные значения, но для создания action игр они 
будут полезны, так как дают возможность создавать реалистичное звуковое пространство с удаляющимися 
источниками звука и прочими фишками. 
\lstinputlisting[firstline=25, lastline=30]{../game/02_minimal/src/sound.cpp}

Далее идёт деструктор. 
\lstinputlisting[firstline=34, lastline=44]{../game/02_minimal/src/sound.cpp}

В нём нет ничего особенного, кроме как удаления всех звуковых источников в цикле. Остальные же действия 
освобождают звуковой контекст и используемое устройство.

\pagebreak

Пока пропустим самую главную функцию \emph{load} и рассмотрим остальные.
\lstinputlisting[firstline=106, lastline=125]{../game/02_minimal/src/sound.cpp}

Данные функции используют стандартные функции библиотеки OpenAL по работе со звуковым источником. Они просты 
и не должны вызвать затруднений. Сделаем небольшое уточнение по функции воспроизведения: чтобы воспроизвести 
звуковой источник его нужно выбрать, а потом уже воспроизводить (как и реализованно в данной функции).

Теперь когда мы рассмотрели почти все функции перейдём к самой главной -- загрузки \emph{load}. Идея состоит 
в следующем: при вызове функции мы создаём новый источник звука, производим его настройки и создаём звуковой 
буфер
\lstinputlisting[firstline=57, lastline=68]{../game/02_minimal/src/sound.cpp}

Далее мы производим загрузку и декодирование аудио файла в формате ogg
\lstinputlisting[firstline=70, lastline=93]{../game/02_minimal/src/sound.cpp}

Здесь мы используем возможности библиотеки vorbis по чтению и декодированию аудио файла. Ну и под конец 
загружаем данные в буфер, далее переносим буфер в звуковой источник и освобождаем используемые данные
\lstinputlisting[firstline=95, lastline=102]{../game/02_minimal/src/sound.cpp}

Под конец мы возвращаем значение, которое будет указывать на данный звуковой файл для последующего 
использования в программе.

\section{Заключение}
На этом заканчивается работа со звуковой системой. Она получилась довольно простой в реализации (не считая 
функции загрузки). Подробнее вы всегда можете почитать в интернете с большим количеством примеров. А далее 
мы перейдём непосредственно к разработке игры 
Asteroids.

\chapter{Создание прототипа}
В данном разделе мы непосредственно переходим к разработке игры. Здесь будет много кода с объяснением его 
работы. Начнём мы с простого -- рисования всех игровых объектов, далее рассмотрим организацию движений всех 
объектов, их взаимодействий в разделе связанный с физикой игры и закончим рейтинговой и бонусной системой. 

\section{Рисование}
Для того чтобы реализовать доступ к каждому элементу в наших классах: \emph{Player}, \emph{AsteroidSystem} и 
\emph{BulletSystem} мы добавим в ниш следующую функцию имеющую одинаковую реализацию:
\lstinputlisting[firstline=25, lastline=25]{../game/02_minimal/src/asteroid.hpp}

Данный метод даёт полный доступ к приватным значениям класса, что бывает очень удобно. Теперь давайте 
рассмотрим подробнее рисование объектов по отдельности.

\subsection{AsteroidSystem}
Как ранее упоминалось в данной системе мы будем использовать немного другой способ рисования окружности, а 
точнее окружность с искажениями. Поэтому было заранее создано несколько массивов с данными, которые сейчас 
будут нужно. Но для начала давайте опишем основные действия, по которым мы будем действовать.
\begin{enumerate}\itemsep-5pt
    \item установить цвет астероида
    \item выбрать астероид
    \item сформировать координаты
    \item нарисовать астероид
    \item перейти к пункту 2 если есть ещё астероиды
    \item вернуть цвет фона
\end{enumerate}

В коде это будет выглядеть следующим образом:
\lstinputlisting[firstline=98, lastline=121]{../game/02_minimal/src/asteroid.cpp}

По рисованию не должно возникнуть вопросов, а вот по методу формирования искажений астероидов наверное 
будут. Идея состоит в следующем: сделать небольшие сдвиги при формировании окружности, которые будут похожи 
на неровности как у астероидов. Следующий код иллюстрирует данный подход
\lstinputlisting[firstline=13, lastline=19]{../game/02_minimal/src/asteroid.cpp}

В данном случае мы формируем массив неровностей по количеству астероидов, а при создании нового астероида мы 
присваиваем ему одно из индексов на данные искажения. Поэтому каждый астероид выглядит по разному, так как 
имеет разный размер и набор искажений. Далее мы только собираем все эти значения в общую кучу, поворачиваем 
на угол отклонения данного астероида и рисуем его.

\pagebreak

\subsection{BulletSystem}
С классом BulletSystem обстоит всё просто и тривиально. Мы просто проходим по списку со снарядами и рисуем 
каждый из них маленькой окружностью.
\lstinputlisting[firstline=53, lastline=61]{../game/02_minimal/src/bullet.cpp}

\subsection{Player}
А вот игрок уже имеет более сложную структуру. Здесь мы уже рисуем объект линиями из заготовленных 
координатных вершин. Плюс ко всему нужно учесть, что при столкновении с астероидом игрок теряет одну жизнь и 
начинает мерцать некоторое время (режим неуязвимости), которая реализуется выпадением кадров в рисовании 
игрока. Собственно все в коде говорит само за себя:
\lstinputlisting[firstline=73, lastline=97]{../game/02_minimal/src/player.cpp}

\subsection{Основная программа}
И наконец переходя к основной программе. Реализация рисования будет очень простой задачей, так как мы уже 
определили основной метод остаётся передать лишь ссылку на DrawSystem и объекты будут нарисованы.

\begin{lstlisting}
    Player player;
    // система отрисовки
    DrawSystem draw( nullptr, 16 );
    // система снарядов
    BulletSystem bullet( 5, 80, 2 );
    // система астероидов
    AsteroidSystem asteroid( gw.width, gw.height, 16, 16 );
    ...
    // отрисовка
    void game_render( void ) {
        // очищаем окно
        SDL_RenderClear( gw.render );
        // рисуем игрока
        player.draw( draw );
        // рисуем снаряды
        bullet.draw( draw );
        // рисуем астероиды
        asteroid.draw( draw );
        // сообщаем SDL о конце отрисовки
        SDL_RenderPresent( gw.render );
    }
\end{lstlisting}

Данный код будет рисовать все наши объекты, но так как нет функций которые отвечают за их расположение и 
движение, то в большой вероятности мы их просто не увидим. Поэтому мы плавно переходим к следующему разделу.

\pagebreak

\section{Движение}
Для организации движения всем объектам мы создадим в каждом классе новую функцию:
\lstinputlisting[firstline=24, lastline=24]{../game/02_minimal/src/asteroid.hpp}

В которую передаются размеры игрового окна. Конечно это не самая лучшая идея и нужно было делать абстракцию 
игровой комнаты, но мы пойдём более простым путём. Теперь давайте рассмотрим подробнее её реализации для 
каждого класса.

\subsection{AsteroidSystem}
В данной функции мы будем управлять всеми существующими астероидами. Основные пункты, которые мы должны 
реализовать:
\begin{enumerate}
    \item удаление астероидов с истекшим временем жизни
    \item передвижение астероидов, с учётом игровой комнаты
    \item обработка внутренних столкновений
\end{enumerate}

Последний пункт мы рассмотрим подробнее в разделе \ref{ast:collide}. Поэтому не стоит обращать особое 
внимание на последний цикл.
\lstinputlisting[firstline=61, lastline=96]{../game/02_minimal/src/asteroid.cpp}

Код
\lstinputlisting[firstline=63, lastline=65]{../game/02_minimal/src/asteroid.cpp}
проходит по списку с астероидами и удаляет только те, которые удовлетворяют следующему условию 
\( life \leq 0 \). Функция реализована в формате лямбда, поэтому не забудьте, чтобы компилятор поддерживал её.

Движение реализовано простым \textbf{вычитанием}\footnote{Так как здесь центр координат находится в левом 
верхнем углу.} векторов позиции и скорости. 

Следующий код не даёт улететь астероидам за игровую комнату и реализует связь краёв комнаты друг с другом.
\lstinputlisting[firstline=72, lastline=83]{../game/02_minimal/src/asteroid.cpp}

Последняя же функция организует плавный поворот астероида с зацикливанием в \( [0, 2\pi] \).
\lstinputlisting[firstline=84, lastline=85]{../game/02_minimal/src/asteroid.cpp}

\newpage

\subsection{BulletSystem}
Со снарядами дела обстоят аналогично, с небольшими отличиями в расчёт координат и уменьшении жизни при 
каждом прохождении цикла.
\lstinputlisting[firstline=24, lastline=51]{../game/02_minimal/src/bullet.cpp}

Для того чтобы как-то ограничить время жизни пули (да, и не засорять память) у них есть параметр, который 
уменьшается с каждым проходом цикла и при достижении нуля, алгоритм расписанный ранее удаляет пулю из массива.

\newpage

\subsection{Player}
У игрового персонажа также присутствует блок зацикливания в игровом поле, передвижение в пространстве, но 
также и есть блоки, которые отвечают за ограничение по скорости и времени неуязвимости.
\lstinputlisting[firstline=42, lastline=70]{../game/02_minimal/src/player.cpp}

\newpage

\section{Физика}
В данном разделе рассмотрим обработку столкновений игровых объектов между собой. Давайте рассмотрим 
подробнее каждую из них.

\subsection{Взаимодействие внутри AsteroidSystem}
Мы подошли к тому пункту, когда рассмотрим ранее упоминавшуюся функцию
\lstinputlisting[firstline=29, lastline=29]{../game/02_minimal/src/asteroid.hpp}
которая отвечает за взаимодействия между астероидами. Давайте рассмотрим её подробнее.

Для того чтобы упростить задачу и не обрабатывать пересечения каждой из граней у каждого астероида мы 
сделаем более просто -- будем считать астероиды окружностями и находить взаимное пересечение двух 
окружностей, а далее расталкивать их в разные стороны по нормалям.
\lstinputlisting[firstline=123, lastline=137]{../game/02_minimal/src/asteroid.cpp}

Функция довольно проста. Сначала мы получаем все ссылки на скорости и координаты двух рассматриваемых 
астероидов, высчитываем расстояние между их центрами и вычитаем из суммы радиусов астероидов. Если 
полученное значение больше или равно нулю, то мы имеем взаимное пересечение. И в этом случае мы расталкиваем 
астероиды в разных направлениях с учётом обмена их скоростей\footnote{Будем считать что массы астероидов 
равны, хотя это не так.}. Всё это обрабатывается в функции \emph{step}
\lstinputlisting[firstline=87, lastline=94]{../game/02_minimal/src/asteroid.cpp}
где мы сравниваем каждый с каждым.

\newpage

\subsection{Взаимодействие AsteroidSystem-BulletSystem}
\label{ast:collide}
Для обработки столкновений между снарядами и астероидами добавим в класс BulletSystem следующую функцию:
\lstinputlisting[firstline=85, lastline=92]{../game/02_minimal/src/bullet.hpp}

Данная функция принимает ссылку на класс AsteroidSystem, для того чтобы мы могли найти их взаимные 
пересечения и при столкновении произвести определённые действия. Эта функция будет возвращать количество 
очков, которые мы получили при уничтожении астероида -- в дальнейшем будет понятно почему именно так.

Для нахождения взаимных пересечений между астероидом и снарядом реализуем аналогичную функцию из прошлого 
пункта, которая будет возвращать факт пересечения.
\lstinputlisting[firstline=67, lastline=77]{../game/02_minimal/src/bullet.cpp}

Далее будем исходить из идеи, что если у нас произошло пересечение между снарядом и астероидом, то мы 
создаём несколько астероидов поменьше (при условии, что они получаться больше минимального радиуса), 
удаляем текущий снаряд и астероид и подсчитываем заработанные очки и возвращаем результат. Следующий код 
иллюстрирует данный подход
\lstinputlisting[firstline=79, lastline=110]{../game/02_minimal/src/bullet.cpp}

Создание астероидов производится вспомогательной функцией
\lstinputlisting[firstline=53, lastline=58]{../game/02_minimal/src/asteroid.cpp}

\subsection{Взаимодействие AsteroidSystem-Player}
Ну и наконец обработка самого главного столкновение: между астероидом и игроком. Здесь мы пойдём другим 
путём и реализуем проверку на пересечение отрезка и окружности. Но для начала давайте добавим в класс 
Player следующий метод:
\lstinputlisting[firstline=27, lastline=27]{../game/02_minimal/src/player.hpp}

Функция, которая будет проверять пересечение между астероидом и отрезком представлена следующим кодом. На 
текущий момент, я не могу предоставить нормальных объяснений её принципа работы, поэтому оставляю это на 
читателя.
\lstinputlisting[firstline=99, lastline=114]{../game/02_minimal/src/player.cpp}

Ну а насчёт функции \emph{collider} всё обстоит также просто как и всегда. Сначала формируем все линии 
игрового персонажа (которые мы будем проверять на пересечение), а далее начинаем проходить по списку с 
астероидами и проверять на пересечение с любой из линий. Если пересечение существует, то мы уничтожаем 
астероид, а вместо него создаём несколько поменьше и возвращаем \emph{true}, указывая на то, что произошло 
столкновение.
\lstinputlisting[firstline=116, lastline=151]{../game/02_minimal/src/player.cpp}

\newpage

\section{Игровой счёт и бонусы}
Подсчёт игровых очков в реализации игры имеют тесную связь. Поэтому будем следовать следующей идеей: при 
уничтожении астероида начисляются очки и когда они достигают каждые 10000 будем добавлять игроку одну 
бонусную жизнь. Это легко проиллюстрировать следующим кодом:
\begin{lstlisting}
    // обработка столкновения снарядов с астероидами
    add_score = bullet.collider( asteroid );
    if ( add_score > 0 ) {
        // добавляем очки при попадании
        game_score += add_score;
        // проигрываем звук взрыва астероида
        sound.play( sound_explosion, false );
    }
    ...
    // добавляем одну жизнь каждые 10000 очков
    if ( game_score > 0 && log10( game_score - last_score ) >= 4 ) {
        last_score = game_score;
        // проигрываем звук бонуса
        sound.play( sound_bonus, false );
        player.add_life( 1 );
    }
\end{lstlisting}

\section{Заключение}
На этом заканчивается рассмотрение последнего раздела данного пособия. Все, что нужно было реализовать для 
этого готово. Теперь читателю только остаётся собрать всё вместе и игра будет готова. В данной реализации 
есть ещё много неоговоренных моментов, так что полноценной реализации игры обратитесь к исходному коду в 
разделе \ref{source:code}, где вы можете пройти по ссылке и посмотреть на готовую реализацию игры Asteroid.

\chapter{Справка}

\section{Исходный код}
\label{source:code}
Исходный код данного мануала и реализованной игры доступны по следующим ссылкам:\\
\url{https://github.com/FreeCX/study/tree/master/cad-fac/it/manual}\\
\url{https://github.com/FreeCX/study/tree/master/cad-fac/it/game/02_minimal}

\subsection{Скелет программы на SDL2}
\label{code:skeletonSDL2}
\lstinputlisting{../game/01_init/src/sdl2_init.cpp}

\pagebreak

\subsection{Скелет программы на GLUT}
\label{code:skeletonGLUT}
\lstinputlisting{../game/01_init/src/glut_init.cpp}

\pagebreak

\subsection{Класс vec2}
\label{code:vec2}
\begin{center}
    Заголовочный файл \emph{math.hpp}
\end{center}
\lstinputlisting{../game/02_minimal/src/math.hpp}

\pagebreak

\begin{center}
    Исходный код \emph{math.cpp}
\end{center}
\lstinputlisting{../game/02_minimal/src/math.cpp}

\pagebreak

\subsection{Функция aaline}
\label{code:aaline}
\begin{center}
    Исходный код функции aaline
\end{center}
\lstinputlisting[firstline=49, lastline=113]{../game/02_minimal/src/draw.cpp}

\pagebreak

\section{Полезные ресурсы разработчику}
Если у вас в команде нет художников или музыкантов, или вам нужно узнать определённые подробности по работе 
с тем или иным инструментом, то во многих случаях можно воспользоваться помощью интернета. Заказать у 
художника арты, у композитора фоновую музыку или обсудить тонкий вопрос по использования специфичного 
алгоритма, то в данном случае лучшим решением будет обратиться к следующим интернет источникам.

\begin{itemize}\itemsep-5pt
    \item FAQ по геймдизайну \url{http://www.sloperama.com/advice.html}
    \item Авторский блог Антона Карпова по разработке игр \url{http://www.ant-karlov.ru/}
    \item Аналог stackoverflow по gamedev \url{http://gamedev.stackexchange.com/}
    \item Блог посвященный созданию 2D графики\\
        \url{http://2dgameartforprogrammers.blogspot.ru/}
    \item Блог Райана Швайдера по gamedesign \url{http://www.nerfbat.com/lessons/}
    \item Источник свободных игровых ресурсов (CC0) \url{http://opengameart.org/}
    \item Крупнейшее сообщество модостроителей \url{http://moddb.com/}
    \item Крупные сообщества по игрострою \url{http://www.gamedev.ru/} (rus) и\\
        \url{http://www.gamedev.net/} (eng)
    \item Любительские конкурсы по разработке игр \url{http://igdc.ru/}
    \item Новости индустрии, блоги разработчиков и многое другое \url{http://gamasutra.com/}
    \item Сайт для специалистов по компьютерной графике \url{http://devmaster.net/}
    \item Сайт посвященный pixelart \url{http://www.pixeljoint.com/}
    \item Уроки по созданию 3D \url{http://www.digitaltutors.com/}
    \item Игровые спрайты старый игр \url{http://www.videogamesprites.net/}
    \item Свободный игровой контент \url{http://freegamearts.tuxfamily.org/}
    \item База свободных звуков \url{http://www.freesound.org/}
    \item Открытый музыкальный архив \url{http://www.openmusicarchive.org/}
    \item Базы 3D моделей \url{http://www.katorlegaz.com/3d_models/index.php}\\
        \url{https://3dwarehouse.sketchup.com/}
    \item CG текстуры \url{http://www.cgtextures.com/}
    \item Свободные архивы по текстурам \url{http://www.mayang.com/textures/}\\
        \url{http://www.texturearchive.com/}
    \item Библиотеки шрифтов \url{http://openfontlibrary.org/}\\
        \url{https://www.acidfonts.com/}
    \item Хабрахабр \url{http://habrahabr.ru}
    \item Invent Your Own Computer Games with Python\\
        \url{https://inventwithpython.com/chapters/}
    \item Making Games with Python \& Pygame\\
        \url{https://inventwithpython.com/pygame/chapters/}
    \item Sylvester,~T. Designing Games: A Guide to Engineering Experiences. O'Reilly Media, 2013
    \item Nystrom,~R. Game Programming Patterns \url{http://gameprogrammingpatterns.com/}
\end{itemize}