\documentclass[14pt,final,titlepage,pscyr]{hedwork}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[derivative]{hedmaths}
\usepackage{graphicx}
\usepackage{array}
\usepackage{listings}
\usepackage{hyperref}

\graphicspath{{img/}}
\renewcommand{\vec}[1]{\mathbf{#1}}

\lstdefinelanguage{OpenCL}{morekeywords=
	{__kernel,kernel,__local,local,__global,global,% 
		__constant,constant,__private,private,% 
		char2,char3,char4,char8,char16,% 
		uchar2,uchar3,uchar4,uchar8,uchar16,% 
		short2,short3,short4,short8,short16,% 
		ushort2,ushort3,ushort4,ushort8,ushort16,% 
		int2,int3,int4,int8,int16,% 
		uint2,uint3,uint4,uint8,uint16,% 
		long2,long3,long4,long8,long16,% 
		ulong2,ulong3,ulong4,ulong8,ulong16,% 
		float2,float3,float4,float8,float16,% 
		image2d_t,image3d_t,sampler_t,event_t,% 
		bool2,bool3,bool4,bool8,bool16,% 
		half2,half3,half4,half8,half16,% 
		quad,quad2,quad3,quad4,quad8,quad16,% 
		complex,imaginary},% 
}% 

\faculty{Факультет электроники и вычислительной техники}
\department{<<САПР и ПК>>}
\subject{Вычислительные системы и сетевые технологии}
\topic{Решение системы ОДУ методом Рунге-Кутты 4 порядка}
\variant{9}
\student[m]{студент группы САПР-1.1п\\Голубев~А.~В.}
\teacher[m]{доцент технических наук Андреев~А.~А.}

\begin{document}
\maketitle
\tableofcontents
\section{Постановка задач}
	\begin{enumerate}
		\item Реализовать с использованием технологий параллельных вычислений задание по вариантам 
			(минимум 2 технологии: MPI и Open MP, CUDA и Open MP, OpenMP / OpenCL, Xeon Phi + MPI, 
			MPI / GridGain, cloud computing и т.д.)
		\item Оценить ускорение, степень параллелизма и другие параметры своих реализаций. Построить 
			таблицы и графики на основании тестирования (в зависимости от числа узлов / ядер и от 
			размерности задачи).
		\item Пройти он-лайн тестирование по курсам (\url{www.intuit.ru}): С.А. Немнюгин Основы MPI и 
			Введение в облачные вычисления 
	\end{enumerate}
\section{Параллельная реализация явного метода Рунге-Кутты}
	Метод Рунге -- Кутты позволяет получать одношаговые разностные схемы различного порядка точности, в 
	которых в зависимости от точности выбранной формулы правая часть системы может на рассматриваемом шаге 
	вычисляется несколько раз.

	Для построения вычислительных схем методов Рунге -- Кутты четвёртого порядка в тейлоровском разложении 
	искомого решения \( \vec{y}(t) \) учитываются члены, содержащие степени шага \( h = t_{m+1} - t_m \) до 
	четвёртой включительно, наиболее часто используемой из которых является следующая:
	\begin{equation}
		\vec{y}_{m+1} = \vec{y}_m + \frac{\left( \vec{k}_1 + 2\vec{k}_2 + 2\vec{k}_3 + \vec{k}_4 \right)}{6}
		\label{eq8.9}
	\end{equation}
	где 
	\begin{gather}
		\vec{k}_1 = h\vec{f}\left(t_m, \vec{y}_m \right), \notag \\
		\vec{k}_2 = h\vec{f}\left(t_m + \frac{h}{2}, \vec{y}_m + \frac{\vec{k}_1}{2} \right), \notag \\
		\vec{k}_3 = h\vec{f}\left(t_m + \frac{h}{2}, \vec{y}_m + \frac{\vec{k}_2}{2} \right), \notag \\
		\vec{k}_4 = h\vec{f}\left(t_m + h, \vec{y}_m + \vec{k}_3 \right). \notag
	\end{gather}

	Схема \eqref{eq8.9} на каждом шаге \( h \) требует четырёх последовательных вычислений правой части 
	системы ОДУ для определения значений \( \vec{k}_1, \vec{k}_2, \vec{k}_3, \vec{k}_4 \).

	Поскольку в описанной выше вычислительной схеме наиболее трудоёмкой является операции расчёта правых 
	частей ОДУ при вычислении \( \vec{k}_i (i = 1, 2, 3, 4) \), то основное внимание следует уделить 
	распараллеливанию этой операции. Будем применять поход декомпозиции уравнений системы ОДУ на подсистемы. 
	Поэтому для инициализации рассмотрим следующую схему декомпозиции данных по имеющимся процессорным 
	элементам с локальной памятью: на каждый \( \mu \)-й ПЭ \( \mu = 0, \ldots, p - 1 ) \) распределяется 
	\( n/p \) дифференциальных уравнений и вектор \( \vec{y}_0 \in \mathbb{R}^n \). Далее расчёты 
	производятся по следующей схеме:
	\begin{enumerate}
		\item на каждой ПЭ одновременно вычисляются \( n/p \) соответствующих компонент вектора 
			\( \vec{k}_1 \) по формуле 
			\[ \left[ \vec{k}_1 \right]_\mu = h\left[ \vec{f}(t_m, \vec{y}_m) \right]_\mu; \]
		\item для обеспечения второго расчётного этапа необходимо провести сборку вектора \( \vec{k}_1 \) 
			целиком на каждом ПЭ. Затем независимо выполняется вычисление компонент вектора \( \vec{k}_2 \) 
			по формуле 
			\[ 
				\left[ \vec{k}_2 \right]_\mu = 
					h\left[ 
						\vec{f}(t_m + \frac{h}{2}, \vec{y}_m + \frac{\vec{k}_1}{2}) 
					\right]_\mu; 
			\]
		\item проводится сборка вектора \( \vec{k}_2 \) на каждом ПЭ, вычисляются компоненты вектора 
			\( \vec{k}_3 \): 
			\[ 
				\left[ \vec{k}_3 \right]_\mu = 
				h\left[ 
					\vec{f}(t_m + \frac{h}{2}, \vec{y}_m + \frac{\vec{k}_2}{2}) 
				\right]_\mu; 
			\]
		\item проводится сборка вектора \( \vec{k}_3 \) на каждом ПЭ, вычисляются компоненты вектора 
			\( \vec{k}_4 \):
			\[ \left[ \vec{k}_4 \right]_\mu = h\left[ \vec{f}(t_m, \vec{y}_m + \vec{k}_3 ) \right]_\mu; \]
		\item рассчитываются с идеальным параллелизмом компоненты вектора \( \vec{y}_{m+1} \) : 
			\[
				\left[ \vec{y}_{m+1} \right]_\mu = \left[ \vec{y}_m \right]_\mu + \frac{1}{6}\left( 
					\left[ \vec{k}_1 \right]_\mu + 2\left[ \vec{k}_2 \right]_\mu + 
					2\left[ \vec{k}_3 \right]_\mu + \left[ \vec{k}_4 \right]_\mu
				\right)
			\]
			и производится сборка вектора \( \vec{y}_{m+1} \) на каждом ПЭ. Если необходимо продолжить 
			вычислительный процесс, то полагается \( m = m + 1 \) и осуществляется переход на пункт 1.
	\end{enumerate}

	Заметим, что в данном алгоритме производится четыре операции вычисления вектора правых частей ОДУ, 
	шестнадцать операций сложения векторов и умножения вектора на число и четыре операции глобальной 
	сборки векторов. 

	В случае, когда \( \vec{f}(t, \vec{y}(t)) \equiv A \times \vec{y}(t) \), где 
	\( A \in \mathbb{R}^{n\times n} \) -- матрица с постоянными коэффициентами, можно получить алгоритм, 
	который имеет меньшее число межпроцессорных пересылок данных на одной итерации метода Рунге -- Кутты. 
	Для этого построим оператор перехода для одного вычислительного шага, позволяющий определить 
	значение вектора неизвестных на следующей итерации \( \vec{y}_{m+1} \) через \( \vec{y}_m \). 
	Преобразуем значения \( \vec{k}_1, \vec{k}_2, \vec{k}_3, \vec{k}_4 \):
	\begin{gather}
		\vec{k}_1 = hA\vec{y}_m, \notag \\
		\vec{k}_2 = hA\left(\vec{y}_m + \frac{\vec{k}_1}{2}\right) = 
			\vec{k}_1 + \left(\frac{h}{2}\right)A\vec{k}_1 = 
			\left( E + \left(\frac{h}{2}\right)A \right)\vec{k}_1 = 
			h\left( E + \left(\frac{h}{2}A \right)A \right) \vec{y}_m, \notag \\
		\vec{k}_3 = hA\left( \vec{y}_m + \frac{1}{2}\vec{k}_2 \right) = 
			\vec{k}_1 + \left( \frac{h}{2} \right)A\vec{k}_2 = 
			\vec{k}_1 + \left( \frac{h}{2} \right)A\left( \vec{k}_1 + 
			\left( \frac{h}{2} \right)A\vec{k}_1 \right) = \notag \\ =
			h\left( E + \left( \frac{h}{2} \right)A + \left( \frac{h}{2} \right)^2 A^2 \right)A\vec{y}_m, 
		\notag \\
		\vec{k}_4 = hA\left( \vec{y}_m + \vec{k}_3 \right) = 
			\vec{k}_1 + \left( hA + \left( \frac{h^2}{2} \right)A^2 + 
				\left( \frac{h^3}{4} \right)A^3 \right)\vec{k}_1 = \notag \\ = 
			h\left( E + hA + \left( \frac{h^2}{2} \right)A^2 + 
				\left( \frac{h^3}{4} \right)A^3 \right)A\vec{y}_m
		\notag
	\end{gather}
	и, подставив из в \eqref{eq8.9}, получим
	\begin{gather}
		\vec{y}_{m+1} = B\vec{y}_m; \quad
		B = E + hA\left( E + \left( \frac{h}{2} \right)A\left( 
			E + \left( \frac{h}{3} \right) A \left( E + \left( \frac{h}{4} \right)A \right) 
		\right) \right)
		\label{eq8.10}
	\end{gather}
	где \( B \) -- оператор перехода.

	Рассчитав заранее матрицу \( B \), получим вычислительный алгоритм, в котором каждое новое значение 
	вектора \( \vec{y}_{m+1} \) определяется за один шаг умножения матрицы \( B \) на вектор.

	При параллельной реализации \eqref{eq8.10} умножение блочных строк матрицы \( B \) на вектора 
	\( \vec{y}_m \) будет проводиться одновременно и независимо. Потребуется только после каждого 
	вычислительного шага по \eqref{eq8.10} проводить сборку вектора \( \vec{y}_{m+1} \) на всех процессорных 
	элементах.\cite{methods}

\section{Используемый пример}
В качестве примера используем систему ОДУ для расчёта направления силовых линий для различных векторных 
полей. Систему уравнений можно записать следующим образом:

\[
	\vec{A}(\vec{0}) = \vec{r}_0, \quad \cfrac{d\vec{r}}{dt} = \vec{A}\left( \vec{r}(t) \right)
\]

где \( \vec{A}(\vec{r}) \) -- векторное поле, \( \vec{r}(t) \) -- интегральная кривая, 
\( \vec{r}_0 \) -- начальное условие.

\section{Последовательная программа}
% результаты тестов
% оценка ускорения
\section{Подход к распараллеливанию}
% параллелизм данных / задачи
% основные моменты
\section{Результаты}
% число ядер / узлов
% размерность
\section{Выводы}

\newpage

\renewcommand{\bibname}{Список используемой литературы}
\addcontentsline{toc}{section}{Список используемой литературы}
\begin{thebibliography}{10}
	\bibitem{methods} Cтарченко, А.~В. Методы параллельных вычислений~/ А.~В. Старченко, В.~Н. Берцун ~// 
		Томский государственный университет "--- 2013
	\bibitem{theory} Назарова, И.~А. Параллельные полностью неявные методы численного решения жестких 
		задач для СОДУ~/ И.~А. Назарова ~// Донецкий национальный технический университет "--- 2005
\end{thebibliography}

\newpage

\addcontentsline{toc}{section}{Приложение}
\centerОбщая часть для всех программ:
\lstinputlisting[language=C++, basicstyle=\tiny, firstline=12, lastline=109]{code/rk_kernel_default.cpp}

\newpage

Ядро последовательной программы:
\lstinputlisting[language=C++, basicstyle=\tiny, firstline=116]{code/rk_kernel_default.cpp}

\newpage

Ядро программы использующая OpenMP:
\lstinputlisting[language=C++, basicstyle=\tiny, firstline=117]{code/rk_kernel_openmp.cpp}

\newpage

Ядро программы использующая потоки:
\lstinputlisting[language=C++, basicstyle=\tiny, firstline=116]{code/rk_kernel_thread.cpp}

\newpage

Ядро программы использующая OpenCL:
\lstinputlisting[language=OpenCL, basicstyle=\tiny, firstline=116]{code/rk_kernel_opencl.cl}

Настройка и работа с OpenCL:
\lstinputlisting[language=C++, basicstyle=\tiny, firstline=8]{code/opencl_init.cpp}

\end{document}
